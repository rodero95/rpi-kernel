<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver: dwc_otg_hcd_intr.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>dwc_otg_hcd_intr.c</h1><a href="dwc__otg__hcd__intr_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/* ==========================================================================</span>
00002 <span class="comment"> * $File: //dwh/usb_iip/dev/software/otg/linux/drivers/dwc_otg_hcd_intr.c $</span>
00003 <span class="comment"> * $Revision: #89 $</span>
00004 <span class="comment"> * $Date: 2011/10/20 $</span>
00005 <span class="comment"> * $Change: 1869487 $</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,</span>
00008 <span class="comment"> * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless</span>
00009 <span class="comment"> * otherwise expressly agreed to in writing between Synopsys and you.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * The Software IS NOT an item of Licensed Software or Licensed Product under</span>
00012 <span class="comment"> * any End User Software License Agreement or Agreement for Licensed Product</span>
00013 <span class="comment"> * with Synopsys or any supplement thereto. You are permitted to use and</span>
00014 <span class="comment"> * redistribute this Software in source and binary forms, with or without</span>
00015 <span class="comment"> * modification, provided that redistributions of source code must retain this</span>
00016 <span class="comment"> * notice. You may not view, use, disclose, copy or distribute this file or</span>
00017 <span class="comment"> * any information contained herein except pursuant to this license grant from</span>
00018 <span class="comment"> * Synopsys. If you do not agree with this notice, including the disclaimer</span>
00019 <span class="comment"> * below, then you are not authorized to use the Software.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS</span>
00022 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00023 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
00024 <span class="comment"> * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,</span>
00025 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
00026 <span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
00027 <span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
00028 <span class="comment"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
00029 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
00030 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
00031 <span class="comment"> * DAMAGE.</span>
00032 <span class="comment"> * ========================================================================== */</span>
00033 <span class="preprocessor">#ifndef DWC_DEVICE_ONLY</span>
00034 <span class="preprocessor"></span>
00035 <span class="preprocessor">#include "<a class="code" href="dwc__otg__hcd_8h.html">dwc_otg_hcd.h</a>"</span>
00036 <span class="preprocessor">#include "<a class="code" href="dwc__otg__regs_8h.html">dwc_otg_regs.h</a>"</span>
00037 
<a name="l00043"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a0">00043</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a0">dwc_otg_hcd_handle_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00044 {
00045         <span class="keywordtype">int</span> retval = 0;
00046 
00047         <a class="code" href="structdwc__otg__core__if.html">dwc_otg_core_if_t</a> *core_if = dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>;
00048         <a class="code" href="uniongintsts__data.html">gintsts_data_t</a> gintsts;
00049 <span class="preprocessor">#ifdef DEBUG</span>
00050 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__core__global__regs.html">dwc_otg_core_global_regs_t</a> *global_regs = core_if-&gt;<a class="code" href="structdwc__otg__core__if.html#o1">core_global_regs</a>;
00051 <span class="preprocessor">#endif</span>
00052 <span class="preprocessor"></span>
00053         <span class="comment">/* Exit from ISR if core is hibernated */</span>
00054         <span class="keywordflow">if</span> (core_if-&gt;<a class="code" href="structdwc__otg__core__if.html#o45">hibernation_suspend</a> == 1) {
00055                 <span class="keywordflow">return</span> retval;
00056         }
00057         DWC_SPINLOCK(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>);
00058         <span class="comment">/* Check if HOST Mode */</span>
00059         <span class="keywordflow">if</span> (dwc_otg_is_host_mode(core_if)) {
00060                 gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a> = <a class="code" href="dwc__otg__cil_8h.html#a107">dwc_otg_read_core_intr</a>(core_if);
00061                 <span class="keywordflow">if</span> (!gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a>) {
00062                         DWC_SPINUNLOCK(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>);
00063                         <span class="keywordflow">return</span> 0;
00064                 }
00065 <span class="preprocessor">#ifdef DEBUG</span>
00066 <span class="preprocessor"></span>                <span class="comment">/* Don't print debug message in the interrupt handler on SOF */</span>
00067 <span class="preprocessor">#ifndef DEBUG_SOF</span>
00068 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a> != DWC_SOF_INTR_MASK)
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>                        <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"\n"</span>);
00071 <span class="preprocessor">#endif</span>
00072 <span class="preprocessor"></span>
00073 <span class="preprocessor">#ifdef DEBUG</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#ifndef DEBUG_SOF</span>
00075 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a> != DWC_SOF_INTR_MASK)
00076 <span class="preprocessor">#endif</span>
00077 <span class="preprocessor"></span>                        <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>,
00078                                     <span class="stringliteral">"DWC OTG HCD Interrupt Detected gintsts&amp;gintmsk=0x%08x\n"</span>,
00079                                     gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a>);
00080 <span class="preprocessor">#endif</span>
00081 <span class="preprocessor"></span>
00082                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o4">sofintr</a>) {
00083                         retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a1">dwc_otg_hcd_handle_sof_intr</a>(dwc_otg_hcd);
00084                 }
00085                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o5">rxstsqlvl</a>) {
00086                         retval |=
00087                             <a class="code" href="dwc__otg__hcd_8h.html#a35">dwc_otg_hcd_handle_rx_status_q_level_intr</a>
00088                             (dwc_otg_hcd);
00089                 }
00090                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o6">nptxfempty</a>) {
00091                         retval |=
00092                             <a class="code" href="dwc__otg__hcd_8h.html#a36">dwc_otg_hcd_handle_np_tx_fifo_empty_intr</a>
00093                             (dwc_otg_hcd);
00094                 }
00095                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o10">i2cintr</a>) {
00097                 }
00098                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o25">portintr</a>) {
00099                         retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a5">dwc_otg_hcd_handle_port_intr</a>(dwc_otg_hcd);
00100                 }
00101                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o26">hcintr</a>) {
00102                         retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a6">dwc_otg_hcd_handle_hc_intr</a>(dwc_otg_hcd);
00103                 }
00104                 <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o27">ptxfempty</a>) {
00105                         retval |=
00106                             <a class="code" href="dwc__otg__hcd_8h.html#a37">dwc_otg_hcd_handle_perio_tx_fifo_empty_intr</a>
00107                             (dwc_otg_hcd);
00108                 }
00109 <span class="preprocessor">#ifdef DEBUG</span>
00110 <span class="preprocessor"></span><span class="preprocessor">#ifndef DEBUG_SOF</span>
00111 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a> != DWC_SOF_INTR_MASK)
00112 <span class="preprocessor">#endif</span>
00113 <span class="preprocessor"></span>                {
00114                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>,
00115                                     <span class="stringliteral">"DWC OTG HCD Finished Servicing Interrupts\n"</span>);
00116                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"DWC OTG HCD gintsts=0x%08x\n"</span>,
00117                                     DWC_READ_REG32(&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o5">gintsts</a>));
00118                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"DWC OTG HCD gintmsk=0x%08x\n"</span>,
00119                                     DWC_READ_REG32(&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o6">gintmsk</a>));
00120                 }
00121 <span class="preprocessor">#endif</span>
00122 <span class="preprocessor"></span>
00123 <span class="preprocessor">#ifdef DEBUG</span>
00124 <span class="preprocessor"></span><span class="preprocessor">#ifndef DEBUG_SOF</span>
00125 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a> != DWC_SOF_INTR_MASK)
00126 <span class="preprocessor">#endif</span>
00127 <span class="preprocessor"></span>                        <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"\n"</span>);
00128 <span class="preprocessor">#endif</span>
00129 <span class="preprocessor"></span>
00130         }
00131         DWC_SPINUNLOCK(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>);
00132         <span class="keywordflow">return</span> retval;
00133 }
00134 
00135 <span class="preprocessor">#ifdef DWC_TRACK_MISSED_SOFS</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#warning Compiling code to track missed SOFs</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define FRAME_NUM_ARRAY_SIZE 1000</span>
00138 <span class="preprocessor"></span>
00141 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> track_missed_sofs(uint16_t curr_frame_number)
00142 {
00143         <span class="keyword">static</span> uint16_t frame_num_array[FRAME_NUM_ARRAY_SIZE];
00144         <span class="keyword">static</span> uint16_t last_frame_num_array[FRAME_NUM_ARRAY_SIZE];
00145         <span class="keyword">static</span> <span class="keywordtype">int</span> frame_num_idx = 0;
00146         <span class="keyword">static</span> uint16_t last_frame_num = DWC_HFNUM_MAX_FRNUM;
00147         <span class="keyword">static</span> <span class="keywordtype">int</span> dumped_frame_num_array = 0;
00148 
00149         <span class="keywordflow">if</span> (frame_num_idx &lt; FRAME_NUM_ARRAY_SIZE) {
00150                 <span class="keywordflow">if</span> (((last_frame_num + 1) &amp; DWC_HFNUM_MAX_FRNUM) !=
00151                     curr_frame_number) {
00152                         frame_num_array[frame_num_idx] = curr_frame_number;
00153                         last_frame_num_array[frame_num_idx++] = last_frame_num;
00154                 }
00155         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!dumped_frame_num_array) {
00156                 <span class="keywordtype">int</span> i;
00157                 DWC_PRINTF(<span class="stringliteral">"Frame     Last Frame\n"</span>);
00158                 DWC_PRINTF(<span class="stringliteral">"-----     ----------\n"</span>);
00159                 <span class="keywordflow">for</span> (i = 0; i &lt; FRAME_NUM_ARRAY_SIZE; i++) {
00160                         DWC_PRINTF(<span class="stringliteral">"0x%04x    0x%04x\n"</span>,
00161                                    frame_num_array[i], last_frame_num_array[i]);
00162                 }
00163                 dumped_frame_num_array = 1;
00164         }
00165         last_frame_num = curr_frame_number;
00166 }
00167 <span class="preprocessor">#endif</span>
00168 <span class="preprocessor"></span>
<a name="l00175"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a1">00175</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a1">dwc_otg_hcd_handle_sof_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00176 {
00177         <a class="code" href="unionhfnum__data.html">hfnum_data_t</a> hfnum;
00178         dwc_list_link_t *qh_entry;
00179         <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> *qh;
00180         <a class="code" href="dwc__otg__hcd_8h.html#a8">dwc_otg_transaction_type_e</a> tr_type;
00181         <a class="code" href="uniongintsts__data.html">gintsts_data_t</a> gintsts = {.<a class="code" href="uniongintsts__data.html#o0">d32</a> = 0 };
00182 
00183         hfnum.<a class="code" href="unionhfnum__data.html#o0">d32</a> =
00184             DWC_READ_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o2">hfnum</a>);
00185 
00186 <span class="preprocessor">#ifdef DEBUG_SOF</span>
00187 <span class="preprocessor"></span>        <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Start of Frame Interrupt--\n"</span>);
00188 <span class="preprocessor">#endif</span>
00189 <span class="preprocessor"></span>        hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a> = hfnum.<a class="code" href="unionhfnum__data.html#o3">b</a>.<a class="code" href="unionhfnum__data.html#o1">frnum</a>;
00190 
00191 <span class="preprocessor">#ifdef DEBUG</span>
00192 <span class="preprocessor"></span>        hcd-&gt;frrem_accum += hfnum.<a class="code" href="unionhfnum__data.html#o3">b</a>.<a class="code" href="unionhfnum__data.html#o2">frrem</a>;
00193         hcd-&gt;frrem_samples++;
00194 <span class="preprocessor">#endif</span>
00195 <span class="preprocessor"></span>
00196 <span class="preprocessor">#ifdef DWC_TRACK_MISSED_SOFS</span>
00197 <span class="preprocessor"></span>        track_missed_sofs(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a>);
00198 <span class="preprocessor">#endif</span>
00199 <span class="preprocessor"></span>        <span class="comment">/* Determine whether any periodic QHs should be executed. */</span>
00200         qh_entry = DWC_LIST_FIRST(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o7">periodic_sched_inactive</a>);
00201         <span class="keywordflow">while</span> (qh_entry != &amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o7">periodic_sched_inactive</a>) {
00202                 qh = DWC_LIST_ENTRY(qh_entry, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a>, qh_list_entry);
00203                 qh_entry = qh_entry-&gt;next;
00204                 <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__hcd_8h.html#a65">dwc_frame_num_le</a>(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_2">sched_frame</a>, hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a>)) {
00205                         <span class="comment">/*</span>
00206 <span class="comment">                         * Move QH to the ready list to be executed next</span>
00207 <span class="comment">                         * (micro)frame.</span>
00208 <span class="comment">                         */</span>
00209                         DWC_LIST_MOVE_HEAD(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o8">periodic_sched_ready</a>,
00210                                            &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o11">qh_list_entry</a>);
00211                 }
00212         }
00213         tr_type = <a class="code" href="dwc__otg__hcd_8h.html#a31">dwc_otg_hcd_select_transactions</a>(hcd);
00214         <span class="keywordflow">if</span> (tr_type != DWC_OTG_TRANSACTION_NONE) {
00215                 <a class="code" href="dwc__otg__hcd_8h.html#a32">dwc_otg_hcd_queue_transactions</a>(hcd, tr_type);
00216         }
00217 
00218         <span class="comment">/* Clear interrupt */</span>
00219         gintsts.<a class="code" href="uniongintsts__data.html#o33">b</a>.<a class="code" href="uniongintsts__data.html#o4">sofintr</a> = 1;
00220         DWC_WRITE_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o1">core_global_regs</a>-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o5">gintsts</a>, gintsts.<a class="code" href="uniongintsts__data.html#o0">d32</a>);
00221 
00222         <span class="keywordflow">return</span> 1;
00223 }
00224 
<a name="l00228"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a2">00228</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a2">dwc_otg_hcd_handle_rx_status_q_level_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00229 {
00230         <a class="code" href="unionhost__grxsts__data.html">host_grxsts_data_t</a> grxsts;
00231         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> *hc = NULL;
00232 
00233         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--RxStsQ Level Interrupt--\n"</span>);
00234 
00235         grxsts.<a class="code" href="unionhost__grxsts__data.html#o0">d32</a> =
00236             DWC_READ_REG32(&amp;dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o1">core_global_regs</a>-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o8">grxstsp</a>);
00237 
00238         hc = dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o17">hc_ptr_array</a>[grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o1">chnum</a>];
00239         <span class="keywordflow">if</span> (!hc) {
00240                 DWC_ERROR(<span class="stringliteral">"Unable to get corresponding channel\n"</span>);
00241                 <span class="keywordflow">return</span> 0;
00242         }
00243 
00244         <span class="comment">/* Packet Status */</span>
00245         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"    Ch num = %d\n"</span>, grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o1">chnum</a>);
00246         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"    Count = %d\n"</span>, grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o2">bcnt</a>);
00247         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"    DPID = %d, hc.dpid = %d\n"</span>, grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o3">dpid</a>,
00248                     hc-&gt;<a class="code" href="structdwc__hc.html#o7">data_pid_start</a>);
00249         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"    PStatus = %d\n"</span>, grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o4">pktsts</a>);
00250 
00251         <span class="keywordflow">switch</span> (grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o4">pktsts</a>) {
00252         <span class="keywordflow">case</span> DWC_GRXSTS_PKTSTS_IN:
00253                 <span class="comment">/* Read the data into the host buffer. */</span>
00254                 <span class="keywordflow">if</span> (grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o2">bcnt</a> &gt; 0) {
00255                         <a class="code" href="dwc__otg__cil_8h.html#a103">dwc_otg_read_packet</a>(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>,
00256                                             hc-&gt;<a class="code" href="structdwc__hc.html#z34_0">xfer_buff</a>, grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o2">bcnt</a>);
00257 
00258                         <span class="comment">/* Update the HC fields for the next packet received. */</span>
00259                         hc-&gt;<a class="code" href="structdwc__hc.html#z34_3">xfer_count</a> += grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o2">bcnt</a>;
00260                         hc-&gt;<a class="code" href="structdwc__hc.html#z34_0">xfer_buff</a> += grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o2">bcnt</a>;
00261                 }
00262 
00263         <span class="keywordflow">case</span> DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
00264         <span class="keywordflow">case</span> DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
00265         <span class="keywordflow">case</span> DWC_GRXSTS_PKTSTS_CH_HALTED:
00266                 <span class="comment">/* Handled in interrupt, just ignore data */</span>
00267                 <span class="keywordflow">break</span>;
00268         <span class="keywordflow">default</span>:
00269                 DWC_ERROR(<span class="stringliteral">"RX_STS_Q Interrupt: Unknown status %d\n"</span>,
00270                           grxsts.<a class="code" href="unionhost__grxsts__data.html#o6">b</a>.<a class="code" href="unionhost__grxsts__data.html#o4">pktsts</a>);
00271                 <span class="keywordflow">break</span>;
00272         }
00273 
00274         <span class="keywordflow">return</span> 1;
00275 }
00276 
<a name="l00281"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a3">00281</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a3">dwc_otg_hcd_handle_np_tx_fifo_empty_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00282 {
00283         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Non-Periodic TxFIFO Empty Interrupt--\n"</span>);
00284         <a class="code" href="dwc__otg__hcd_8h.html#a32">dwc_otg_hcd_queue_transactions</a>(dwc_otg_hcd,
00285                                        DWC_OTG_TRANSACTION_NON_PERIODIC);
00286         <span class="keywordflow">return</span> 1;
00287 }
00288 
<a name="l00293"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a4">00293</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a4">dwc_otg_hcd_handle_perio_tx_fifo_empty_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00294 {
00295         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Periodic TxFIFO Empty Interrupt--\n"</span>);
00296         <a class="code" href="dwc__otg__hcd_8h.html#a32">dwc_otg_hcd_queue_transactions</a>(dwc_otg_hcd,
00297                                        DWC_OTG_TRANSACTION_PERIODIC);
00298         <span class="keywordflow">return</span> 1;
00299 }
00300 
<a name="l00304"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a5">00304</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a5">dwc_otg_hcd_handle_port_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00305 {
00306         <span class="keywordtype">int</span> retval = 0;
00307         <a class="code" href="unionhprt0__data.html">hprt0_data_t</a> hprt0;
00308         <a class="code" href="unionhprt0__data.html">hprt0_data_t</a> hprt0_modify;
00309 
00310         hprt0.<a class="code" href="unionhprt0__data.html#o0">d32</a> = DWC_READ_REG32(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o1">hprt0</a>);
00311         hprt0_modify.<a class="code" href="unionhprt0__data.html#o0">d32</a> = DWC_READ_REG32(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o1">hprt0</a>);
00312 
00313         <span class="comment">/* Clear appropriate bits in HPRT0 to clear the interrupt bit in</span>
00314 <span class="comment">         * GINTSTS */</span>
00315 
00316         hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o3">prtena</a> = 0;
00317         hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o2">prtconndet</a> = 0;
00318         hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o4">prtenchng</a> = 0;
00319         hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o6">prtovrcurrchng</a> = 0;
00320 
00321         <span class="comment">/* Port Connect Detected</span>
00322 <span class="comment">         * Set flag and clear if detected */</span>
00323         <span class="keywordflow">if</span> (dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o45">hibernation_suspend</a> == 1) {
00324                 <span class="comment">// Dont modify port status if we are in hibernation state</span>
00325                 hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o2">prtconndet</a> = 1;
00326                 hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o4">prtenchng</a> = 1;
00327                 DWC_WRITE_REG32(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o1">hprt0</a>, hprt0_modify.<a class="code" href="unionhprt0__data.html#o0">d32</a>);
00328                 hprt0.<a class="code" href="unionhprt0__data.html#o0">d32</a> = DWC_READ_REG32(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o1">hprt0</a>);
00329                 <span class="keywordflow">return</span> retval;
00330         }
00331 
00332         <span class="keywordflow">if</span> (hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o2">prtconndet</a>) {
00334                 <span class="keywordflow">if</span> (dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o43">adp_enable</a> &amp;&amp;         
00335                                 dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o44">adp</a>.vbuson_timer_started == 1) {
00336                         DWC_PRINTF(<span class="stringliteral">"PORT CONNECT DETECTED ----------------\n"</span>);
00337                         DWC_TIMER_CANCEL(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o44">adp</a>.vbuson_timer);
00338                         dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o44">adp</a>.vbuson_timer_started = 0;
00339                         <span class="comment">/* TODO - check if this is required, as</span>
00340 <span class="comment">                         * host initialization was already performed</span>
00341 <span class="comment">                         * after initial ADP probing</span>
00342 <span class="comment">                         */</span>
00343                         <span class="comment">/*dwc_otg_hcd-&gt;core_if-&gt;adp.vbuson_timer_started = 0;</span>
00344 <span class="comment">                        dwc_otg_core_init(dwc_otg_hcd-&gt;core_if);</span>
00345 <span class="comment">                        dwc_otg_enable_global_interrupts(dwc_otg_hcd-&gt;core_if);</span>
00346 <span class="comment">                        cil_hcd_start(dwc_otg_hcd-&gt;core_if);*/</span>
00347                 } <span class="keywordflow">else</span> {
00348                 
00349                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Port Interrupt HPRT0=0x%08x "</span>
00350                                     <span class="stringliteral">"Port Connect Detected--\n"</span>, hprt0.<a class="code" href="unionhprt0__data.html#o0">d32</a>);
00351                         dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o3">flags</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o9">b</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o1">port_connect_status_change</a> = 1;
00352                         dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o3">flags</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o9">b</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o2">port_connect_status</a> = 1;
00353                         hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o2">prtconndet</a> = 1;
00354         
00355                         <span class="comment">/* B-Device has connected, Delete the connection timer. */</span>
00356                         DWC_TIMER_CANCEL(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o20">conn_timer</a>);
00357                 }
00358                 <span class="comment">/* The Hub driver asserts a reset when it sees port connect</span>
00359 <span class="comment">                 * status change flag */</span>
00360                 retval |= 1;
00361         }
00362 
00363         <span class="comment">/* Port Enable Changed</span>
00364 <span class="comment">         * Clear if detected - Set internal flag if disabled */</span>
00365         <span class="keywordflow">if</span> (hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o4">prtenchng</a>) {
00366                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"  --Port Interrupt HPRT0=0x%08x "</span>
00367                             <span class="stringliteral">"Port Enable Changed--\n"</span>, hprt0.<a class="code" href="unionhprt0__data.html#o0">d32</a>);
00368                 hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o4">prtenchng</a> = 1;
00369                 <span class="keywordflow">if</span> (hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o3">prtena</a> == 1) {
00370                         <a class="code" href="unionhfir__data.html">hfir_data_t</a> hfir;
00371                         <span class="keywordtype">int</span> do_reset = 0;
00372                         <a class="code" href="structdwc__otg__core__params.html">dwc_otg_core_params_t</a> *params =
00373                             dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o0">core_params</a>;
00374                         <a class="code" href="structdwc__otg__core__global__regs.html">dwc_otg_core_global_regs_t</a> *global_regs =
00375                             dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o1">core_global_regs</a>;
00376                         <a class="code" href="structdwc__otg__host__if.html">dwc_otg_host_if_t</a> *host_if =
00377                             dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>;
00378                             
00379                         <span class="comment">/* Every time when port enables calculate</span>
00380 <span class="comment">                         * HFIR.FrInterval</span>
00381 <span class="comment">                         */</span>
00382                         hfir.<a class="code" href="unionhfir__data.html#o0">d32</a> = DWC_READ_REG32(&amp;host_if-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o1">hfir</a>);
00383                         hfir.<a class="code" href="unionhfir__data.html#o4">b</a>.<a class="code" href="unionhfir__data.html#o1">frint</a> = <a class="code" href="dwc__otg__cil_8h.html#a101">calc_frame_interval</a>(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>);
00384                         DWC_WRITE_REG32(&amp;host_if-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o1">hfir</a>, hfir.<a class="code" href="unionhfir__data.html#o0">d32</a>);
00385 
00386                         <span class="comment">/* Check if we need to adjust the PHY clock speed for</span>
00387 <span class="comment">                         * low power and adjust it */</span>
00388                         <span class="keywordflow">if</span> (params-&gt;<a class="code" href="structdwc__otg__core__params.html#o6">host_support_fs_ls_low_power</a>) {
00389                                 <a class="code" href="uniongusbcfg__data.html">gusbcfg_data_t</a> usbcfg;
00390 
00391                                 usbcfg.<a class="code" href="uniongusbcfg__data.html#o0">d32</a> =
00392                                     DWC_READ_REG32(&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o3">gusbcfg</a>);
00393 
00394                                 <span class="keywordflow">if</span> (hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o14">prtspd</a> == DWC_HPRT0_PRTSPD_LOW_SPEED
00395                                     || hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o14">prtspd</a> ==
00396                                     DWC_HPRT0_PRTSPD_FULL_SPEED) {
00397                                         <span class="comment">/*</span>
00398 <span class="comment">                                         * Low power</span>
00399 <span class="comment">                                         */</span>
00400                                         <a class="code" href="unionhcfg__data.html">hcfg_data_t</a> hcfg;
00401                                         <span class="keywordflow">if</span> (usbcfg.<a class="code" href="uniongusbcfg__data.html#o28">b</a>.<a class="code" href="uniongusbcfg__data.html#o11">phylpwrclksel</a> == 0) {
00402                                                 <span class="comment">/* Set PHY low power clock select for FS/LS devices */</span>
00403                                                 usbcfg.<a class="code" href="uniongusbcfg__data.html#o28">b</a>.<a class="code" href="uniongusbcfg__data.html#o11">phylpwrclksel</a> = 1;
00404                                                 DWC_WRITE_REG32
00405                                                     (&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o3">gusbcfg</a>,
00406                                                      usbcfg.<a class="code" href="uniongusbcfg__data.html#o0">d32</a>);
00407                                                 do_reset = 1;
00408                                         }
00409 
00410                                         hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a> =
00411                                             DWC_READ_REG32
00412                                             (&amp;host_if-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>);
00413 
00414                                         <span class="keywordflow">if</span> (hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o14">prtspd</a> ==
00415                                             DWC_HPRT0_PRTSPD_LOW_SPEED
00416                                             &amp;&amp; params-&gt;<a class="code" href="structdwc__otg__core__params.html#o7">host_ls_low_power_phy_clk</a>
00417                                             ==
00418                                             DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ)
00419                                         {
00420                                                 <span class="comment">/* 6 MHZ */</span>
00421                                                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a0">DBG_CIL</a>,
00422                                                             <span class="stringliteral">"FS_PHY programming HCFG to 6 MHz (Low Power)\n"</span>);
00423                                                 <span class="keywordflow">if</span> (hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o1">fslspclksel</a> !=
00424                                                     DWC_HCFG_6_MHZ) {
00425                                                         hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o1">fslspclksel</a> =
00426                                                             DWC_HCFG_6_MHZ;
00427                                                         DWC_WRITE_REG32
00428                                                             (&amp;host_if-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>,
00429                                                              hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a>);
00430                                                         do_reset = 1;
00431                                                 }
00432                                         } <span class="keywordflow">else</span> {
00433                                                 <span class="comment">/* 48 MHZ */</span>
00434                                                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a0">DBG_CIL</a>,
00435                                                             <span class="stringliteral">"FS_PHY programming HCFG to 48 MHz ()\n"</span>);
00436                                                 <span class="keywordflow">if</span> (hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o1">fslspclksel</a> !=
00437                                                     DWC_HCFG_48_MHZ) {
00438                                                         hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o1">fslspclksel</a> =
00439                                                             DWC_HCFG_48_MHZ;
00440                                                         DWC_WRITE_REG32
00441                                                             (&amp;host_if-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>,
00442                                                              hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a>);
00443                                                         do_reset = 1;
00444                                                 }
00445                                         }
00446                                 } <span class="keywordflow">else</span> {
00447                                         <span class="comment">/*</span>
00448 <span class="comment">                                         * Not low power</span>
00449 <span class="comment">                                         */</span>
00450                                         <span class="keywordflow">if</span> (usbcfg.<a class="code" href="uniongusbcfg__data.html#o28">b</a>.<a class="code" href="uniongusbcfg__data.html#o11">phylpwrclksel</a> == 1) {
00451                                                 usbcfg.<a class="code" href="uniongusbcfg__data.html#o28">b</a>.<a class="code" href="uniongusbcfg__data.html#o11">phylpwrclksel</a> = 0;
00452                                                 DWC_WRITE_REG32
00453                                                     (&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o3">gusbcfg</a>,
00454                                                      usbcfg.<a class="code" href="uniongusbcfg__data.html#o0">d32</a>);
00455                                                 do_reset = 1;
00456                                         }
00457                                 }
00458 
00459                                 <span class="keywordflow">if</span> (do_reset) {
00460                                         DWC_TASK_SCHEDULE(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o21">reset_tasklet</a>);
00461                                 }
00462                         }
00463 
00464                         <span class="keywordflow">if</span> (!do_reset) {
00465                                 <span class="comment">/* Port has been enabled set the reset change flag */</span>
00466                                 dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o3">flags</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o9">b</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o3">port_reset_change</a> = 1;
00467                         }
00468                 } <span class="keywordflow">else</span> {
00469                         dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o3">flags</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o9">b</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o4">port_enable_change</a> = 1;
00470                 }
00471                 retval |= 1;
00472         }
00473 
00475         <span class="keywordflow">if</span> (hprt0.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o6">prtovrcurrchng</a>) {
00476                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"  --Port Interrupt HPRT0=0x%08x "</span>
00477                             <span class="stringliteral">"Port Overcurrent Changed--\n"</span>, hprt0.<a class="code" href="unionhprt0__data.html#o0">d32</a>);
00478                 dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o3">flags</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o9">b</a>.<a class="code" href="uniondwc__otg__hcd_1_1dwc__otg__hcd__internal__flags.html#o6">port_over_current_change</a> = 1;
00479                 hprt0_modify.<a class="code" href="unionhprt0__data.html#o16">b</a>.<a class="code" href="unionhprt0__data.html#o6">prtovrcurrchng</a> = 1;
00480                 retval |= 1;
00481         }
00482 
00483         <span class="comment">/* Clear Port Interrupts */</span>
00484         DWC_WRITE_REG32(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o1">hprt0</a>, hprt0_modify.<a class="code" href="unionhprt0__data.html#o0">d32</a>);
00485 
00486         <span class="keywordflow">return</span> retval;
00487 }
00488 
<a name="l00493"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a6">00493</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a6">dwc_otg_hcd_handle_hc_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00494 {
00495         <span class="keywordtype">int</span> i;
00496         <span class="keywordtype">int</span> retval = 0;
00497         <a class="code" href="unionhaint__data.html">haint_data_t</a> haint;
00498 
00499         <span class="comment">/* Clear appropriate bits in HCINTn to clear the interrupt bit in</span>
00500 <span class="comment">         * GINTSTS */</span>
00501 
00502         haint.<a class="code" href="unionhaint__data.html#o0">d32</a> = <a class="code" href="dwc__otg__cil_8h.html#a113">dwc_otg_read_host_all_channels_intr</a>(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>);
00503 
00504         <span class="keywordflow">for</span> (i = 0; i &lt; dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o0">core_params</a>-&gt;<a class="code" href="structdwc__otg__core__params.html#o18">host_channels</a>; i++) {
00505                 <span class="keywordflow">if</span> (haint.<a class="code" href="unionhaint__data.html#o20">b2</a>.<a class="code" href="unionhaint__data.html#o19">chint</a> &amp; (1 &lt;&lt; i)) {
00506                         retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a30">dwc_otg_hcd_handle_hc_n_intr</a>(dwc_otg_hcd, i);
00507                 }
00508         }
00509 
00510         <span class="keywordflow">return</span> retval;
00511 }
00512 
<a name="l00523"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a7">00523</a> <span class="keyword">static</span> uint32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a7">get_actual_xfer_length</a>(<a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00524                                        <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00525                                        <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd,
00526                                        dwc_otg_halt_status_e halt_status,
00527                                        <span class="keywordtype">int</span> *short_read)
00528 {
00529         <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
00530         uint32_t length;
00531 
00532         <span class="keywordflow">if</span> (short_read != NULL) {
00533                 *short_read = 0;
00534         }
00535         hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
00536 
00537         <span class="keywordflow">if</span> (halt_status == DWC_OTG_HC_XFER_COMPLETE) {
00538                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00539                         length = hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a> - hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o1">xfersize</a>;
00540                         <span class="keywordflow">if</span> (short_read != NULL) {
00541                                 *short_read = (hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o1">xfersize</a> != 0);
00542                         }
00543                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o8">do_split</a>) {
00544                         length = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o3">ssplit_out_xfer_count</a>;
00545                 } <span class="keywordflow">else</span> {
00546                         length = hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a>;
00547                 }
00548         } <span class="keywordflow">else</span> {
00549                 <span class="comment">/*</span>
00550 <span class="comment">                 * Must use the hctsiz.pktcnt field to determine how much data</span>
00551 <span class="comment">                 * has been transferred. This field reflects the number of</span>
00552 <span class="comment">                 * packets that have been transferred via the USB. This is</span>
00553 <span class="comment">                 * always an integral number of packets if the transfer was</span>
00554 <span class="comment">                 * halted before its normal completion. (Can't use the</span>
00555 <span class="comment">                 * hctsiz.xfersize field because that reflects the number of</span>
00556 <span class="comment">                 * bytes transferred via the AHB, not the USB).</span>
00557 <span class="comment">                 */</span>
00558                 length =
00559                     (hc-&gt;<a class="code" href="structdwc__hc.html#z34_4">start_pkt_count</a> - hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o2">pktcnt</a>) * hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a>;
00560         }
00561 
00562         <span class="keywordflow">return</span> length;
00563 }
00564 
<a name="l00574"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a8">00574</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a8">update_urb_state_xfer_comp</a>(<a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00575                                       <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00576                                       dwc_otg_hcd_urb_t * urb,
00577                                       <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
00578 {
00579         <span class="keywordtype">int</span> xfer_done = 0;
00580         <span class="keywordtype">int</span> short_read = 0;
00581 
00582         <span class="keywordtype">int</span> xfer_length;
00583 
00584         xfer_length = <a class="code" href="dwc__otg__hcd__intr_8c.html#a7">get_actual_xfer_length</a>(hc, hc_regs, qtd,
00585                                              DWC_OTG_HC_XFER_COMPLETE,
00586                                              &amp;short_read);
00587 
00588 
00589         <span class="comment">/* non DWORD-aligned buffer case handling. */</span>
00590         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_1">align_buff</a> &amp;&amp; xfer_length &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00591                 dwc_memcpy(urb-&gt;buf + urb-&gt;actual_length, hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o9">dw_align_buf</a>,
00592                            xfer_length);
00593         }
00594 
00595         urb-&gt;actual_length += xfer_length;
00596 
00597         <span class="keywordflow">if</span> (xfer_length &amp;&amp; (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_BULK) &amp;&amp;
00598             (urb-&gt;flags &amp; URB_SEND_ZERO_PACKET)
00599             &amp;&amp; (urb-&gt;actual_length == urb-&gt;length)
00600             &amp;&amp; !(urb-&gt;length % hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a>)) {
00601                 xfer_done = 0;
00602         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (short_read || urb-&gt;actual_length == urb-&gt;length) {
00603                 xfer_done = 1;
00604                 urb-&gt;status = 0;
00605         }
00606         
00607 <span class="preprocessor">#ifdef DEBUG</span>
00608 <span class="preprocessor"></span>        {
00609                 <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
00610                 hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
00611                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"DWC_otg: %s: %s, channel %d\n"</span>,
00612                             __func__, (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> ? <span class="stringliteral">"IN"</span> : <span class="stringliteral">"OUT"</span>),
00613                             hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
00614                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  hc-&gt;xfer_len %d\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a>);
00615                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  hctsiz.xfersize %d\n"</span>,
00616                             hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o1">xfersize</a>);
00617                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  urb-&gt;transfer_buffer_length %d\n"</span>,
00618                             urb-&gt;length);
00619                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  urb-&gt;actual_length %d\n"</span>,
00620                             urb-&gt;actual_length);
00621                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  short_read %d, xfer_done %d\n"</span>,
00622                             short_read, xfer_done);
00623         }
00624 <span class="preprocessor">#endif</span>
00625 <span class="preprocessor"></span>
00626         <span class="keywordflow">return</span> xfer_done;
00627 }
00628 
00629 <span class="comment">/*</span>
00630 <span class="comment"> * Save the starting data toggle for the next transfer. The data toggle is</span>
00631 <span class="comment"> * saved in the QH for non-control transfers and it's saved in the QTD for</span>
00632 <span class="comment"> * control transfers.</span>
00633 <span class="comment"> */</span>
00634 <span class="keywordtype">void</span> dwc_otg_hcd_save_data_toggle(<a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00635                              <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs, <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
00636 {
00637         <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
00638         hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
00639 
00640         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> != DWC_OTG_EP_TYPE_CONTROL) {
00641                 <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> *qh = hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>;
00642                 <span class="keywordflow">if</span> (hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o3">pid</a> == DWC_HCTSIZ_DATA0) {
00643                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#o4">data_toggle</a> = DWC_OTG_HC_PID_DATA0;
00644                 } <span class="keywordflow">else</span> {
00645                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#o4">data_toggle</a> = DWC_OTG_HC_PID_DATA1;
00646                 }
00647         } <span class="keywordflow">else</span> {
00648                 <span class="keywordflow">if</span> (hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o3">pid</a> == DWC_HCTSIZ_DATA0) {
00649                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o0">data_toggle</a> = DWC_OTG_HC_PID_DATA0;
00650                 } <span class="keywordflow">else</span> {
00651                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o0">data_toggle</a> = DWC_OTG_HC_PID_DATA1;
00652                 }
00653         }
00654 }
00655 
00665 <span class="keyword">static</span> dwc_otg_halt_status_e
<a name="l00666"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a10">00666</a> <a class="code" href="dwc__otg__hcd__intr_8c.html#a10">update_isoc_urb_state</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00667                       <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00668                       <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00669                       <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd, dwc_otg_halt_status_e halt_status)
00670 {
00671         dwc_otg_hcd_urb_t *urb = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>;
00672         dwc_otg_halt_status_e ret_val = halt_status;
00673         <span class="keyword">struct </span>dwc_otg_hcd_iso_packet_desc *frame_desc;
00674 
00675         frame_desc = &amp;urb-&gt;iso_descs[qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a>];
00676         <span class="keywordflow">switch</span> (halt_status) {
00677         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_COMPLETE:
00678                 frame_desc-&gt;status = 0;
00679                 frame_desc-&gt;actual_length =
00680                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a7">get_actual_xfer_length</a>(hc, hc_regs, qtd, halt_status, NULL);
00681 
00682                 <span class="comment">/* non DWORD-aligned buffer case handling. */</span>
00683                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_1">align_buff</a> &amp;&amp; frame_desc-&gt;actual_length &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00684                         dwc_memcpy(urb-&gt;buf + frame_desc-&gt;offset + qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a>,
00685                                    hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o9">dw_align_buf</a>, frame_desc-&gt;actual_length);
00686                 }
00687                 
00688                 <span class="keywordflow">break</span>;
00689         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_FRAME_OVERRUN:
00690                 urb-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
00691                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00692                         frame_desc-&gt;status = -DWC_E_NO_STREAM_RES;
00693                 } <span class="keywordflow">else</span> {
00694                         frame_desc-&gt;status = -DWC_E_COMMUNICATION;
00695                 }
00696                 frame_desc-&gt;actual_length = 0;
00697                 <span class="keywordflow">break</span>;
00698         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_BABBLE_ERR:
00699                 urb-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
00700                 frame_desc-&gt;status = -DWC_E_OVERFLOW;
00701                 <span class="comment">/* Don't need to update actual_length in this case. */</span>
00702                 <span class="keywordflow">break</span>;
00703         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_XACT_ERR:
00704                 urb-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
00705                 frame_desc-&gt;status = -DWC_E_PROTOCOL;
00706                 frame_desc-&gt;actual_length =
00707                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a7">get_actual_xfer_length</a>(hc, hc_regs, qtd, halt_status, NULL);
00708 
00709                 <span class="comment">/* non DWORD-aligned buffer case handling. */</span>
00710                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_1">align_buff</a> &amp;&amp; frame_desc-&gt;actual_length &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00711                         dwc_memcpy(urb-&gt;buf + frame_desc-&gt;offset + qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a>,
00712                                    hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o9">dw_align_buf</a>, frame_desc-&gt;actual_length);
00713                 }
00714                 <span class="comment">/* Skip whole frame */</span>
00715                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o8">do_split</a> &amp;&amp; (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC) &amp;&amp;
00716                     hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> &amp;&amp; hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a>) {
00717                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
00718                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> = 0;
00719                 }
00720 
00721                 <span class="keywordflow">break</span>;
00722         <span class="keywordflow">default</span>:
00723                 DWC_ASSERT(1, <span class="stringliteral">"Unhandled _halt_status (%d)\n"</span>, halt_status);
00724                 <span class="keywordflow">break</span>;
00725         }
00726         <span class="keywordflow">if</span> (++qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a> == urb-&gt;packet_count) {
00727                 <span class="comment">/*</span>
00728 <span class="comment">                 * urb-&gt;status is not used for isoc transfers.</span>
00729 <span class="comment">                 * The individual frame_desc statuses are used instead.</span>
00730 <span class="comment">                 */</span>
00731                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, 0);
00732                 ret_val = DWC_OTG_HC_XFER_URB_COMPLETE;
00733         } <span class="keywordflow">else</span> {
00734                 ret_val = DWC_OTG_HC_XFER_COMPLETE;
00735         }
00736         <span class="keywordflow">return</span> ret_val;
00737 }
00738 
<a name="l00746"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a11">00746</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a11">deactivate_qh</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh, <span class="keywordtype">int</span> free_qtd)
00747 {
00748         <span class="keywordtype">int</span> continue_split = 0;
00749         <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> *qtd;
00750 
00751         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  %s(%p,%p,%d)\n"</span>, __func__, hcd, qh, free_qtd);
00752 
00753         qtd = DWC_CIRCLEQ_FIRST(&amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>);
00754 
00755         <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a>) {
00756                 continue_split = 1;
00757         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o6">isoc_split_pos</a> == DWC_HCSPLIT_XACTPOS_MID ||
00758                    qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o6">isoc_split_pos</a> == DWC_HCSPLIT_XACTPOS_END) {
00759                 continue_split = 1;
00760         }
00761 
00762         <span class="keywordflow">if</span> (free_qtd) {
00763                 <a class="code" href="dwc__otg__hcd_8h.html#a59">dwc_otg_hcd_qtd_remove_and_free</a>(hcd, qtd, qh);
00764                 continue_split = 0;
00765         }
00766 
00767         qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a> = NULL;
00768         <a class="code" href="dwc__otg__hcd__queue_8c.html#a17">dwc_otg_hcd_qh_deactivate</a>(hcd, qh, continue_split);
00769 }
00770 
<a name="l00782"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a12">00782</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00783                             <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00784                             <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd,
00785                             dwc_otg_halt_status_e halt_status)
00786 {
00787         <a class="code" href="dwc__otg__hcd_8h.html#a8">dwc_otg_transaction_type_e</a> tr_type;
00788         <span class="keywordtype">int</span> free_qtd;
00789 
00790         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  %s: channel %d, halt_status %d\n"</span>,
00791                     __func__, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>, halt_status);
00792 
00793         <span class="keywordflow">switch</span> (halt_status) {
00794         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_URB_COMPLETE:
00795                 free_qtd = 1;
00796                 <span class="keywordflow">break</span>;
00797         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_AHB_ERR:
00798         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_STALL:
00799         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_BABBLE_ERR:
00800                 free_qtd = 1;
00801                 <span class="keywordflow">break</span>;
00802         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_XACT_ERR:
00803                 <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> &gt;= 3) {
00804                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>,
00805                                     <span class="stringliteral">"  Complete URB with transaction error\n"</span>);
00806                         free_qtd = 1;
00807                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;status = -DWC_E_PROTOCOL;
00808                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv,
00809                                             qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, -DWC_E_PROTOCOL);
00810                 } <span class="keywordflow">else</span> {
00811                         free_qtd = 0;
00812                 }
00813                 <span class="keywordflow">break</span>;
00814         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_URB_DEQUEUE:
00815                 <span class="comment">/*</span>
00816 <span class="comment">                 * The QTD has already been removed and the QH has been</span>
00817 <span class="comment">                 * deactivated. Don't want to do anything except release the</span>
00818 <span class="comment">                 * host channel and try to queue more transfers.</span>
00819 <span class="comment">                 */</span>
00820                 <span class="keywordflow">goto</span> cleanup;
00821         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_NO_HALT_STATUS:
00822                 free_qtd = 0;
00823                 <span class="keywordflow">break</span>;
00824         <span class="keywordflow">case</span> DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE:
00825                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>,
00826                         <span class="stringliteral">"  Complete URB with I/O error\n"</span>);
00827                 free_qtd = 1;
00828                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;status = -DWC_E_IO;
00829                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv,
00830                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, -DWC_E_IO);
00831                 <span class="keywordflow">break</span>;
00832         <span class="keywordflow">default</span>:
00833                 free_qtd = 0;
00834                 <span class="keywordflow">break</span>;
00835         }
00836 
00837         <a class="code" href="dwc__otg__hcd__intr_8c.html#a11">deactivate_qh</a>(hcd, hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>, free_qtd);
00838 
00839 cleanup:
00840         <span class="comment">/*</span>
00841 <span class="comment">         * Release the host channel for use by other transfers. The cleanup</span>
00842 <span class="comment">         * function clears the channel interrupt enables and conditions, so</span>
00843 <span class="comment">         * there's no need to clear the Channel Halted interrupt separately.</span>
00844 <span class="comment">         */</span>
00845         <a class="code" href="dwc__otg__cil_8h.html#a93">dwc_otg_hc_cleanup</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc);
00846         DWC_CIRCLEQ_INSERT_TAIL(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o14">free_hc_list</a>, hc, hc_list_entry);
00847 
00848         <span class="keywordflow">switch</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a>) {
00849         <span class="keywordflow">case</span> DWC_OTG_EP_TYPE_CONTROL:
00850         <span class="keywordflow">case</span> DWC_OTG_EP_TYPE_BULK:
00851                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o16">non_periodic_channels</a>--;
00852                 <span class="keywordflow">break</span>;
00853 
00854         <span class="keywordflow">default</span>:
00855                 <span class="comment">/*</span>
00856 <span class="comment">                 * Don't release reservations for periodic channels here.</span>
00857 <span class="comment">                 * That's done when a periodic transfer is descheduled (i.e.</span>
00858 <span class="comment">                 * when the QH is removed from the periodic schedule).</span>
00859 <span class="comment">                 */</span>
00860                 <span class="keywordflow">break</span>;
00861         }
00862 
00863         <span class="comment">/* Try to queue more transfers now that there's a free channel. */</span>
00864         tr_type = <a class="code" href="dwc__otg__hcd_8h.html#a31">dwc_otg_hcd_select_transactions</a>(hcd);
00865         <span class="keywordflow">if</span> (tr_type != DWC_OTG_TRANSACTION_NONE) {
00866                 <a class="code" href="dwc__otg__hcd_8h.html#a32">dwc_otg_hcd_queue_transactions</a>(hcd, tr_type);
00867         }
00868 }
00869 
<a name="l00880"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a13">00880</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00881                          <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00882                          <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd, dwc_otg_halt_status_e halt_status)
00883 {
00884         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a>) {
00885                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, halt_status);
00886                 <span class="keywordflow">return</span>;
00887         }
00888 
00889         <span class="comment">/* Slave mode processing... */</span>
00890         <a class="code" href="dwc__otg__cil_8h.html#a92">dwc_otg_hc_halt</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc, halt_status);
00891 
00892         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_8">halt_on_queue</a>) {
00893                 <a class="code" href="uniongintmsk__data.html">gintmsk_data_t</a> gintmsk = {.d32 = 0 };
00894                 <a class="code" href="structdwc__otg__core__global__regs.html">dwc_otg_core_global_regs_t</a> *global_regs;
00895                 global_regs = hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o1">core_global_regs</a>;
00896 
00897                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_CONTROL ||
00898                     hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_BULK) {
00899                         <span class="comment">/*</span>
00900 <span class="comment">                         * Make sure the Non-periodic Tx FIFO empty interrupt</span>
00901 <span class="comment">                         * is enabled so that the non-periodic schedule will</span>
00902 <span class="comment">                         * be processed.</span>
00903 <span class="comment">                         */</span>
00904                         gintmsk.<a class="code" href="uniongintmsk__data.html#o33">b</a>.<a class="code" href="uniongintmsk__data.html#o6">nptxfempty</a> = 1;
00905                         DWC_MODIFY_REG32(&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o6">gintmsk</a>, 0, gintmsk.<a class="code" href="uniongintmsk__data.html#o0">d32</a>);
00906                 } <span class="keywordflow">else</span> {
00907                         <span class="comment">/*</span>
00908 <span class="comment">                         * Move the QH from the periodic queued schedule to</span>
00909 <span class="comment">                         * the periodic assigned schedule. This allows the</span>
00910 <span class="comment">                         * halt to be queued when the periodic schedule is</span>
00911 <span class="comment">                         * processed.</span>
00912 <span class="comment">                         */</span>
00913                         DWC_LIST_MOVE_HEAD(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o9">periodic_sched_assigned</a>,
00914                                            &amp;hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o11">qh_list_entry</a>);
00915 
00916                         <span class="comment">/*</span>
00917 <span class="comment">                         * Make sure the Periodic Tx FIFO Empty interrupt is</span>
00918 <span class="comment">                         * enabled so that the periodic schedule will be</span>
00919 <span class="comment">                         * processed.</span>
00920 <span class="comment">                         */</span>
00921                         gintmsk.<a class="code" href="uniongintmsk__data.html#o33">b</a>.<a class="code" href="uniongintmsk__data.html#o27">ptxfempty</a> = 1;
00922                         DWC_MODIFY_REG32(&amp;global_regs-&gt;<a class="code" href="structdwc__otg__core__global__regs.html#o6">gintmsk</a>, 0, gintmsk.<a class="code" href="uniongintmsk__data.html#o0">d32</a>);
00923                 }
00924         }
00925 }
00926 
<a name="l00932"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a14">00932</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a14">complete_non_periodic_xfer</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00933                                        <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00934                                        <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00935                                        <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd,
00936                                        dwc_otg_halt_status_e halt_status)
00937 {
00938         <a class="code" href="unionhcint__data.html">hcint_data_t</a> hcint;
00939 
00940         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
00941 
00942         hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o2">hcint</a>);
00943         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o7">nyet</a>) {
00944                 <span class="comment">/*</span>
00945 <span class="comment">                 * Got a NYET on the last transaction of the transfer. This</span>
00946 <span class="comment">                 * means that the endpoint should be in the PING state at the</span>
00947 <span class="comment">                 * beginning of the next transfer.</span>
00948 <span class="comment">                 */</span>
00949                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a> = 1;
00950                 clear_hc_int(hc_regs, nyet);
00951         }
00952 
00953         <span class="comment">/*</span>
00954 <span class="comment">         * Always halt and release the host channel to make it available for</span>
00955 <span class="comment">         * more transfers. There may still be more phases for a control</span>
00956 <span class="comment">         * transfer or more data packets for a bulk transfer at this point,</span>
00957 <span class="comment">         * but the host channel is still halted. A channel will be reassigned</span>
00958 <span class="comment">         * to the transfer when the non-periodic schedule is processed after</span>
00959 <span class="comment">         * the channel is released. This allows transactions to be queued</span>
00960 <span class="comment">         * properly via dwc_otg_hcd_queue_transactions, which also enables the</span>
00961 <span class="comment">         * Tx FIFO Empty interrupt if necessary.</span>
00962 <span class="comment">         */</span>
00963         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00964                 <span class="comment">/*</span>
00965 <span class="comment">                 * IN transfers in Slave mode require an explicit disable to</span>
00966 <span class="comment">                 * halt the channel. (In DMA mode, this call simply releases</span>
00967 <span class="comment">                 * the channel.)</span>
00968 <span class="comment">                 */</span>
00969                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, halt_status);
00970         } <span class="keywordflow">else</span> {
00971                 <span class="comment">/*</span>
00972 <span class="comment">                 * The channel is automatically disabled by the core for OUT</span>
00973 <span class="comment">                 * transfers in Slave mode.</span>
00974 <span class="comment">                 */</span>
00975                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, halt_status);
00976         }
00977 }
00978 
<a name="l00984"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a15">00984</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a15">complete_periodic_xfer</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00985                                    <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00986                                    <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00987                                    <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd,
00988                                    dwc_otg_halt_status_e halt_status)
00989 {
00990         <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
00991         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
00992 
00993         hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
00994         <span class="keywordflow">if</span> (!hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> || hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o2">pktcnt</a> == 0) {
00995                 <span class="comment">/* Core halts channel in these cases. */</span>
00996                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, halt_status);
00997         } <span class="keywordflow">else</span> {
00998                 <span class="comment">/* Flush any outstanding requests from the Tx queue. */</span>
00999                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, halt_status);
01000         }
01001 }
01002 
01003 <span class="keyword">static</span> int32_t handle_xfercomp_isoc_split_in(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01004                                              <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01005                                              <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01006                                              <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01007 {
01008         uint32_t len;
01009         <span class="keyword">struct </span>dwc_otg_hcd_iso_packet_desc *frame_desc;
01010         frame_desc = &amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;iso_descs[qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a>];
01011 
01012         len = <a class="code" href="dwc__otg__hcd__intr_8c.html#a7">get_actual_xfer_length</a>(hc, hc_regs, qtd,
01013                                      DWC_OTG_HC_XFER_COMPLETE, NULL);
01014 
01015         <span class="keywordflow">if</span> (!len) {
01016                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01017                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> = 0;
01018                 <span class="keywordflow">return</span> 0;
01019         }
01020         frame_desc-&gt;actual_length += len;
01021 
01022         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_1">align_buff</a> &amp;&amp; len)
01023                 dwc_memcpy(qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;buf + frame_desc-&gt;offset +
01024                            qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a>, hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o9">dw_align_buf</a>, len);
01025         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> += len;
01026 
01027         <span class="keywordflow">if</span> (frame_desc-&gt;length == frame_desc-&gt;actual_length) {
01028                 frame_desc-&gt;status = 0;
01029                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a>++;
01030                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01031                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> = 0;
01032         }
01033 
01034         <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a> == qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;packet_count) {
01035                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, 0);
01036                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_URB_COMPLETE);
01037         } <span class="keywordflow">else</span> {
01038                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NO_HALT_STATUS);
01039         }
01040 
01041         <span class="keywordflow">return</span> 1;               <span class="comment">/* Indicates that channel released */</span>
01042 }
01043 
<a name="l01048"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a17">01048</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a17">handle_hc_xfercomp_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01049                                        <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01050                                        <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01051                                        <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01052 {
01053         <span class="keywordtype">int</span> urb_xfer_done;
01054         dwc_otg_halt_status_e halt_status = DWC_OTG_HC_XFER_COMPLETE;
01055         dwc_otg_hcd_urb_t *urb = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>;
01056         <span class="keywordtype">int</span> pipe_type = dwc_otg_hcd_get_pipe_type(&amp;urb-&gt;pipe_info);
01057 
01058         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01059                     <span class="stringliteral">"Transfer Complete--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01060 
01061         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01062                 <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(hcd, hc, hc_regs, halt_status);
01063                 <span class="keywordflow">if</span> (pipe_type == UE_ISOCHRONOUS) {
01064                         <span class="comment">/* Do not disable the interrupt, just clear it */</span>
01065                         clear_hc_int(hc_regs, xfercomp);
01066                         <span class="keywordflow">return</span> 1;
01067                 }
01068                 <span class="keywordflow">goto</span> handle_xfercomp_done;
01069         }
01070 
01071         <span class="comment">/*</span>
01072 <span class="comment">         * Handle xfer complete on CSPLIT.</span>
01073 <span class="comment">         */</span>
01074 
01075         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o8">do_split</a>) {
01076                 <span class="keywordflow">if</span> ((hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC) &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>
01077                     &amp;&amp; hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a>) {
01078                         <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a>
01079                             &amp;&amp; handle_xfercomp_isoc_split_in(hcd, hc, hc_regs,
01080                                                              qtd))
01081                                 <span class="keywordflow">goto</span> handle_xfercomp_done;
01082                 } <span class="keywordflow">else</span> {
01083                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01084                 }
01085         }
01086 
01087         <span class="comment">/* Update the QTD and URB states. */</span>
01088         <span class="keywordflow">switch</span> (pipe_type) {
01089         <span class="keywordflow">case</span> UE_CONTROL:
01090                 <span class="keywordflow">switch</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a>) {
01091                 <span class="keywordflow">case</span> DWC_OTG_CONTROL_SETUP:
01092                         <span class="keywordflow">if</span> (urb-&gt;length &gt; 0) {
01093                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> = DWC_OTG_CONTROL_DATA;
01094                         } <span class="keywordflow">else</span> {
01095                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> = DWC_OTG_CONTROL_STATUS;
01096                         }
01097                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>,
01098                                     <span class="stringliteral">"  Control setup transaction done\n"</span>);
01099                         halt_status = DWC_OTG_HC_XFER_COMPLETE;
01100                         <span class="keywordflow">break</span>;
01101                 <span class="keywordflow">case</span> DWC_OTG_CONTROL_DATA:{
01102                                 urb_xfer_done =
01103                                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a8">update_urb_state_xfer_comp</a>(hc, hc_regs, urb,
01104                                                                qtd);
01105                                 <span class="keywordflow">if</span> (urb_xfer_done) {
01106                                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> =
01107                                             DWC_OTG_CONTROL_STATUS;
01108                                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>,
01109                                                     <span class="stringliteral">"  Control data transfer done\n"</span>);
01110                                 } <span class="keywordflow">else</span> {
01111                                         dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01112                                 }
01113                                 halt_status = DWC_OTG_HC_XFER_COMPLETE;
01114                                 <span class="keywordflow">break</span>;
01115                         }
01116                 <span class="keywordflow">case</span> DWC_OTG_CONTROL_STATUS:
01117                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  Control transfer complete\n"</span>);
01118                         <span class="keywordflow">if</span> (urb-&gt;status == -DWC_E_IN_PROGRESS) {
01119                                 urb-&gt;status = 0;
01120                         }
01121                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, urb-&gt;status);
01122                         halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
01123                         <span class="keywordflow">break</span>;
01124                 }
01125 
01126                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a14">complete_non_periodic_xfer</a>(hcd, hc, hc_regs, qtd, halt_status);
01127                 <span class="keywordflow">break</span>;
01128         <span class="keywordflow">case</span> UE_BULK:
01129                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  Bulk transfer complete\n"</span>);
01130                 urb_xfer_done =
01131                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a8">update_urb_state_xfer_comp</a>(hc, hc_regs, urb, qtd);
01132                 <span class="keywordflow">if</span> (urb_xfer_done) {
01133                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, urb-&gt;status);
01134                         halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
01135                 } <span class="keywordflow">else</span> {
01136                         halt_status = DWC_OTG_HC_XFER_COMPLETE;
01137                 }
01138 
01139                 dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01140                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a14">complete_non_periodic_xfer</a>(hcd, hc, hc_regs, qtd, halt_status);
01141                 <span class="keywordflow">break</span>;
01142         <span class="keywordflow">case</span> UE_INTERRUPT:
01143                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  Interrupt transfer complete\n"</span>);
01144                 urb_xfer_done =
01145                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a8">update_urb_state_xfer_comp</a>(hc, hc_regs, urb, qtd);
01146 
01147                 <span class="comment">/*</span>
01148 <span class="comment">                 * Interrupt URB is done on the first transfer complete</span>
01149 <span class="comment">                 * interrupt.</span>
01150 <span class="comment">                 */</span>
01151                 <span class="keywordflow">if</span> (urb_xfer_done) {
01152                                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, urb-&gt;status);
01153                                 halt_status = DWC_OTG_HC_XFER_URB_COMPLETE;
01154                 } <span class="keywordflow">else</span> {
01155                                 halt_status = DWC_OTG_HC_XFER_COMPLETE;
01156                 }
01157 
01158                 dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01159                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a15">complete_periodic_xfer</a>(hcd, hc, hc_regs, qtd, halt_status);
01160                 <span class="keywordflow">break</span>;
01161         <span class="keywordflow">case</span> UE_ISOCHRONOUS:
01162                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"  Isochronous transfer complete\n"</span>);
01163                 <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o6">isoc_split_pos</a> == DWC_HCSPLIT_XACTPOS_ALL) {
01164                         halt_status =
01165                             <a class="code" href="dwc__otg__hcd__intr_8c.html#a10">update_isoc_urb_state</a>(hcd, hc, hc_regs, qtd,
01166                                                   DWC_OTG_HC_XFER_COMPLETE);
01167                 }
01168                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a15">complete_periodic_xfer</a>(hcd, hc, hc_regs, qtd, halt_status);
01169                 <span class="keywordflow">break</span>;
01170         }
01171 
01172 handle_xfercomp_done:
01173         disable_hc_int(hc_regs, xfercompl);
01174 
01175         <span class="keywordflow">return</span> 1;
01176 }
01177 
<a name="l01182"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a18">01182</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a18">handle_hc_stall_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01183                                     <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01184                                     <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01185                                     <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01186 {
01187         dwc_otg_hcd_urb_t *urb = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>;
01188         <span class="keywordtype">int</span> pipe_type = dwc_otg_hcd_get_pipe_type(&amp;urb-&gt;pipe_info);
01189 
01190         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01191                     <span class="stringliteral">"STALL Received--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01192 
01193         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01194                 <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(hcd, hc, hc_regs, DWC_OTG_HC_XFER_STALL);
01195                 <span class="keywordflow">goto</span> handle_stall_done;
01196         }
01197 
01198         <span class="keywordflow">if</span> (pipe_type == UE_CONTROL) {
01199                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, -DWC_E_PIPE);
01200         }
01201 
01202         <span class="keywordflow">if</span> (pipe_type == UE_BULK || pipe_type == UE_INTERRUPT) {
01203                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, -DWC_E_PIPE);
01204                 <span class="comment">/*</span>
01205 <span class="comment">                 * USB protocol requires resetting the data toggle for bulk</span>
01206 <span class="comment">                 * and interrupt endpoints when a CLEAR_FEATURE(ENDPOINT_HALT)</span>
01207 <span class="comment">                 * setup command is issued to the endpoint. Anticipate the</span>
01208 <span class="comment">                 * CLEAR_FEATURE command since a STALL has occurred and reset</span>
01209 <span class="comment">                 * the data toggle now.</span>
01210 <span class="comment">                 */</span>
01211                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o4">data_toggle</a> = 0;
01212         }
01213 
01214         <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_STALL);
01215 
01216 handle_stall_done:
01217         disable_hc_int(hc_regs, stall);
01218 
01219         <span class="keywordflow">return</span> 1;
01220 }
01221 
01222 <span class="comment">/*</span>
01223 <span class="comment"> * Updates the state of the URB when a transfer has been stopped due to an</span>
01224 <span class="comment"> * abnormal condition before the transfer completes. Modifies the</span>
01225 <span class="comment"> * actual_length field of the URB to reflect the number of bytes that have</span>
01226 <span class="comment"> * actually been transferred via the host channel.</span>
01227 <span class="comment"> */</span>
01228 <span class="keyword">static</span> <span class="keywordtype">void</span> update_urb_state_xfer_intr(<a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01229                                        <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01230                                        dwc_otg_hcd_urb_t * urb,
01231                                        <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd,
01232                                        dwc_otg_halt_status_e halt_status)
01233 {
01234         uint32_t bytes_transferred = <a class="code" href="dwc__otg__hcd__intr_8c.html#a7">get_actual_xfer_length</a>(hc, hc_regs, qtd,
01235                                                             halt_status, NULL);
01236         <span class="comment">/* non DWORD-aligned buffer case handling. */</span>
01237         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_1">align_buff</a> &amp;&amp; bytes_transferred &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
01238                 dwc_memcpy(urb-&gt;buf + urb-&gt;actual_length, hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o9">dw_align_buf</a>,
01239                            bytes_transferred);
01240         }
01241 
01242         urb-&gt;actual_length += bytes_transferred;
01243 
01244 <span class="preprocessor">#ifdef DEBUG</span>
01245 <span class="preprocessor"></span>        {
01246                 <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
01247                 hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
01248                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"DWC_otg: %s: %s, channel %d\n"</span>,
01249                             __func__, (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> ? <span class="stringliteral">"IN"</span> : <span class="stringliteral">"OUT"</span>),
01250                             hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01251                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  hc-&gt;start_pkt_count %d\n"</span>,
01252                             hc-&gt;<a class="code" href="structdwc__hc.html#z34_4">start_pkt_count</a>);
01253                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  hctsiz.pktcnt %d\n"</span>, hctsiz.<a class="code" href="unionhctsiz__data.html#o5">b</a>.<a class="code" href="unionhctsiz__data.html#o2">pktcnt</a>);
01254                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  hc-&gt;max_packet %d\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a>);
01255                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  bytes_transferred %d\n"</span>,
01256                             bytes_transferred);
01257                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  urb-&gt;actual_length %d\n"</span>,
01258                             urb-&gt;actual_length);
01259                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  urb-&gt;transfer_buffer_length %d\n"</span>,
01260                             urb-&gt;length);
01261         }
01262 <span class="preprocessor">#endif</span>
01263 <span class="preprocessor"></span>}
01264 
<a name="l01269"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a20">01269</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a20">handle_hc_nak_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01270                                   <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01271                                   <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01272                                   <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01273 {
01274         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01275                     <span class="stringliteral">"NAK Received--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01276 
01277         <span class="comment">/*</span>
01278 <span class="comment">         * Handle NAK for IN/OUT SSPLIT/CSPLIT transfers, bulk, control, and</span>
01279 <span class="comment">         * interrupt.  Re-start the SSPLIT transfer.</span>
01280 <span class="comment">         */</span>
01281         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_11">do_split</a>) {
01282                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_12">complete_split</a>) {
01283                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01284                 }
01285                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01286                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NAK);
01287                 <span class="keywordflow">goto</span> handle_nak_done;
01288         }
01289 
01290         <span class="keywordflow">switch</span> (dwc_otg_hcd_get_pipe_type(&amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;pipe_info)) {
01291         <span class="keywordflow">case</span> UE_CONTROL:
01292         <span class="keywordflow">case</span> UE_BULK:
01293                 <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a> &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
01294                         <span class="comment">/*</span>
01295 <span class="comment">                         * NAK interrupts are enabled on bulk/control IN</span>
01296 <span class="comment">                         * transfers in DMA mode for the sole purpose of</span>
01297 <span class="comment">                         * resetting the error count after a transaction error</span>
01298 <span class="comment">                         * occurs. The core will continue transferring data.</span>
01299 <span class="comment">                         */</span>
01300                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01301                         <span class="keywordflow">goto</span> handle_nak_done;
01302                 }
01303 
01304                 <span class="comment">/*</span>
01305 <span class="comment">                 * NAK interrupts normally occur during OUT transfers in DMA</span>
01306 <span class="comment">                 * or Slave mode. For IN transfers, more requests will be</span>
01307 <span class="comment">                 * queued as request queue space is available.</span>
01308 <span class="comment">                 */</span>
01309                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01310 
01311                 <span class="keywordflow">if</span> (!hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a>) {
01312                         update_urb_state_xfer_intr(hc, hc_regs,
01313                                                    qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, qtd,
01314                                                    DWC_OTG_HC_XFER_NAK);
01315                         dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01316 
01317                         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a> == DWC_OTG_EP_SPEED_HIGH)
01318                                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a> = 1;
01319                 }
01320 
01321                 <span class="comment">/*</span>
01322 <span class="comment">                 * Halt the channel so the transfer can be re-started from</span>
01323 <span class="comment">                 * the appropriate point or the PING protocol will</span>
01324 <span class="comment">                 * start/continue.</span>
01325 <span class="comment">                 */</span>
01326                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NAK);
01327                 <span class="keywordflow">break</span>;
01328         <span class="keywordflow">case</span> UE_INTERRUPT:
01329                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01330                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NAK);
01331                 <span class="keywordflow">break</span>;
01332         <span class="keywordflow">case</span> UE_ISOCHRONOUS:
01333                 <span class="comment">/* Should never get called for isochronous transfers. */</span>
01334                 DWC_ASSERT(1, <span class="stringliteral">"NACK interrupt for ISOC transfer\n"</span>);
01335                 <span class="keywordflow">break</span>;
01336         }
01337 
01338 handle_nak_done:
01339         disable_hc_int(hc_regs, nak);
01340 
01341         <span class="keywordflow">return</span> 1;
01342 }
01343 
<a name="l01349"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a21">01349</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a21">handle_hc_ack_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01350                                   <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01351                                   <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01352                                   <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01353 {
01354         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01355                     <span class="stringliteral">"ACK Received--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01356 
01357         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_11">do_split</a>) {
01358                 <span class="comment">/*</span>
01359 <span class="comment">                 * Handle ACK on SSPLIT.</span>
01360 <span class="comment">                 * ACK should not occur in CSPLIT.</span>
01361 <span class="comment">                 */</span>
01362                 <span class="keywordflow">if</span> (!hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o7">data_pid_start</a> != DWC_OTG_HC_PID_SETUP) {
01363                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o3">ssplit_out_xfer_count</a> = hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a>;
01364                 }
01365                 <span class="keywordflow">if</span> (!(hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC &amp;&amp; !hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>)) {
01366                         <span class="comment">/* Don't need complete for isochronous out transfers. */</span>
01367                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 1;
01368                 }
01369 
01370                 <span class="comment">/* ISOC OUT */</span>
01371                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC &amp;&amp; !hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
01372                         <span class="keywordflow">switch</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_15">xact_pos</a>) {
01373                         <span class="keywordflow">case</span> DWC_HCSPLIT_XACTPOS_ALL:
01374                                 <span class="keywordflow">break</span>;
01375                         <span class="keywordflow">case</span> DWC_HCSPLIT_XACTPOS_END:
01376                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o6">isoc_split_pos</a> = DWC_HCSPLIT_XACTPOS_ALL;
01377                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> = 0;
01378                                 <span class="keywordflow">break</span>;
01379                         <span class="keywordflow">case</span> DWC_HCSPLIT_XACTPOS_BEGIN:
01380                         <span class="keywordflow">case</span> DWC_HCSPLIT_XACTPOS_MID:
01381                                 <span class="comment">/*</span>
01382 <span class="comment">                                 * For BEGIN or MID, calculate the length for</span>
01383 <span class="comment">                                 * the next microframe to determine the correct</span>
01384 <span class="comment">                                 * SSPLIT token, either MID or END.</span>
01385 <span class="comment">                                 */</span>
01386                                 {
01387                                         <span class="keyword">struct </span>dwc_otg_hcd_iso_packet_desc
01388                                         *frame_desc;
01389 
01390                                         frame_desc =
01391                                             &amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;
01392                                             iso_descs[qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a>];
01393                                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> += 188;
01394 
01395                                         <span class="keywordflow">if</span> ((frame_desc-&gt;length -
01396                                              qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a>) &lt;= 188) {
01397                                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o6">isoc_split_pos</a> =
01398                                                     DWC_HCSPLIT_XACTPOS_END;
01399                                         } <span class="keywordflow">else</span> {
01400                                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o6">isoc_split_pos</a> =
01401                                                     DWC_HCSPLIT_XACTPOS_MID;
01402                                         }
01403 
01404                                 }
01405                                 <span class="keywordflow">break</span>;
01406                         }
01407                 } <span class="keywordflow">else</span> {
01408                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_ACK);
01409                 }
01410         } <span class="keywordflow">else</span> {
01411                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01412 
01413                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a>) {
01414                         hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a> = 0;
01415                         <span class="comment">/*</span>
01416 <span class="comment">                         * Halt the channel so the transfer can be re-started</span>
01417 <span class="comment">                         * from the appropriate point. This only happens in</span>
01418 <span class="comment">                         * Slave mode. In DMA mode, the ping_state is cleared</span>
01419 <span class="comment">                         * when the transfer is started because the core</span>
01420 <span class="comment">                         * automatically executes the PING, then the transfer.</span>
01421 <span class="comment">                         */</span>
01422                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_ACK);
01423                 }
01424         }
01425 
01426         <span class="comment">/*</span>
01427 <span class="comment">         * If the ACK occurred when _not_ in the PING state, let the channel</span>
01428 <span class="comment">         * continue transferring data after clearing the error count.</span>
01429 <span class="comment">         */</span>
01430 
01431         disable_hc_int(hc_regs, ack);
01432 
01433         <span class="keywordflow">return</span> 1;
01434 }
01435 
<a name="l01443"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a22">01443</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a22">handle_hc_nyet_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01444                                    <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01445                                    <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01446                                    <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01447 {
01448         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01449                     <span class="stringliteral">"NYET Received--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01450 
01451         <span class="comment">/*</span>
01452 <span class="comment">         * NYET on CSPLIT</span>
01453 <span class="comment">         * re-do the CSPLIT immediately on non-periodic</span>
01454 <span class="comment">         */</span>
01455         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_11">do_split</a> &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#z34_12">complete_split</a>) {
01456                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> &amp;&amp; (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC)
01457                     &amp;&amp; hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a>) {
01458                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01459                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o7">isoc_split_offset</a> = 0;
01460                         <span class="keywordflow">if</span> (++qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a> == qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;packet_count) {
01461                                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, 0);
01462                                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_URB_COMPLETE);    
01463                         }
01464                         <span class="keywordflow">else</span>
01465                                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NO_HALT_STATUS);  
01466                         <span class="keywordflow">goto</span> handle_nyet_done;
01467                 }
01468                 
01469                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_INTR ||
01470                     hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC) {
01471                         <span class="keywordtype">int</span> frnum = <a class="code" href="dwc__otg__hcd__if_8h.html#a22">dwc_otg_hcd_get_frame_number</a>(hcd);
01472 
01473                         <span class="keywordflow">if</span> (dwc_full_frame_num(frnum) !=
01474                             dwc_full_frame_num(hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#z38_2">sched_frame</a>)) {
01475                                 <span class="comment">/*</span>
01476 <span class="comment">                                 * No longer in the same full speed frame.</span>
01477 <span class="comment">                                 * Treat this as a transaction error.</span>
01478 <span class="comment">                                 */</span>
01479 <span class="preprocessor">#if 0</span>
01480 <span class="preprocessor"></span>
01486                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
01487 <span class="preprocessor">#endif</span>
01488 <span class="preprocessor"></span>                                qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01489                                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd,
01490                                              DWC_OTG_HC_XFER_XACT_ERR);
01492                                 <span class="keywordflow">goto</span> handle_nyet_done;
01493                         }
01494                 }
01495 
01496                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NYET);
01497                 <span class="keywordflow">goto</span> handle_nyet_done;
01498         }
01499 
01500         hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a> = 1;
01501         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01502 
01503         update_urb_state_xfer_intr(hc, hc_regs, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, qtd,
01504                                    DWC_OTG_HC_XFER_NYET);
01505         dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01506 
01507         <span class="comment">/*</span>
01508 <span class="comment">         * Halt the channel and re-start the transfer so the PING</span>
01509 <span class="comment">         * protocol will start.</span>
01510 <span class="comment">         */</span>
01511         <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_NYET);
01512 
01513 handle_nyet_done:
01514         disable_hc_int(hc_regs, nyet);
01515         <span class="keywordflow">return</span> 1;
01516 }
01517 
<a name="l01522"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a23">01522</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a23">handle_hc_babble_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01523                                      <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01524                                      <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01525                                      <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01526 {
01527         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01528                     <span class="stringliteral">"Babble Error--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01529 
01530         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01531                 <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(hcd, hc, hc_regs,
01532                                                DWC_OTG_HC_XFER_BABBLE_ERR);
01533                 <span class="keywordflow">goto</span> handle_babble_done;
01534         }
01535 
01536         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> != DWC_OTG_EP_TYPE_ISOC) {
01537                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv,
01538                                     qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, -DWC_E_OVERFLOW);
01539                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_BABBLE_ERR);
01540         } <span class="keywordflow">else</span> {
01541                 dwc_otg_halt_status_e halt_status;
01542                 halt_status = <a class="code" href="dwc__otg__hcd__intr_8c.html#a10">update_isoc_urb_state</a>(hcd, hc, hc_regs, qtd,
01543                                                     DWC_OTG_HC_XFER_BABBLE_ERR);
01544                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, halt_status);
01545         }
01546 
01547 handle_babble_done:
01548         disable_hc_int(hc_regs, bblerr);
01549         <span class="keywordflow">return</span> 1;
01550 }
01551 
<a name="l01556"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a24">01556</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a24">handle_hc_ahberr_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01557                                      <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01558                                      <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01559                                      <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01560 {
01561         <a class="code" href="unionhcchar__data.html">hcchar_data_t</a> hcchar;
01562         hcsplt_data_t hcsplt;
01563         <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
01564         uint32_t hcdma;
01565         <span class="keywordtype">char</span> *pipetype, *speed;
01566 
01567         dwc_otg_hcd_urb_t *urb = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>;
01568 
01569         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01570                     <span class="stringliteral">"AHB Error--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01571 
01572         hcchar.<a class="code" href="unionhcchar__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o0">hcchar</a>);
01573         hcsplt.<a class="code" href="unionhcchar__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o1">hcsplt</a>);
01574         hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
01575         hcdma = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o5">hcdma</a>);
01576 
01577         DWC_ERROR(<span class="stringliteral">"AHB ERROR, Channel %d\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01578         DWC_ERROR(<span class="stringliteral">"  hcchar 0x%08x, hcsplt 0x%08x\n"</span>, hcchar.<a class="code" href="unionhcchar__data.html#o0">d32</a>, hcsplt.<a class="code" href="unionhcchar__data.html#o0">d32</a>);
01579         DWC_ERROR(<span class="stringliteral">"  hctsiz 0x%08x, hcdma 0x%08x\n"</span>, hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a>, hcdma);
01580         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"DWC OTG HCD URB Enqueue\n"</span>);
01581         DWC_ERROR(<span class="stringliteral">"  Device address: %d\n"</span>,
01582                   dwc_otg_hcd_get_dev_addr(&amp;urb-&gt;pipe_info));
01583         DWC_ERROR(<span class="stringliteral">"  Endpoint: %d, %s\n"</span>,
01584                   dwc_otg_hcd_get_ep_num(&amp;urb-&gt;pipe_info),
01585                   (dwc_otg_hcd_is_pipe_in(&amp;urb-&gt;pipe_info) ? <span class="stringliteral">"IN"</span> : <span class="stringliteral">"OUT"</span>));
01586 
01587         <span class="keywordflow">switch</span> (dwc_otg_hcd_get_pipe_type(&amp;urb-&gt;pipe_info)) {
01588         <span class="keywordflow">case</span> UE_CONTROL:
01589                 pipetype = <span class="stringliteral">"CONTROL"</span>;
01590                 <span class="keywordflow">break</span>;
01591         <span class="keywordflow">case</span> UE_BULK:
01592                 pipetype = <span class="stringliteral">"BULK"</span>;
01593                 <span class="keywordflow">break</span>;
01594         <span class="keywordflow">case</span> UE_INTERRUPT:
01595                 pipetype = <span class="stringliteral">"INTERRUPT"</span>;
01596                 <span class="keywordflow">break</span>;
01597         <span class="keywordflow">case</span> UE_ISOCHRONOUS:
01598                 pipetype = <span class="stringliteral">"ISOCHRONOUS"</span>;
01599                 <span class="keywordflow">break</span>;
01600         <span class="keywordflow">default</span>:
01601                 pipetype = <span class="stringliteral">"UNKNOWN"</span>;
01602                 <span class="keywordflow">break</span>;
01603         }
01604 
01605         DWC_ERROR(<span class="stringliteral">"  Endpoint type: %s\n"</span>, pipetype);
01606 
01607         <span class="keywordflow">switch</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a>) {
01608         <span class="keywordflow">case</span> DWC_OTG_EP_SPEED_HIGH:
01609                 speed = <span class="stringliteral">"HIGH"</span>;
01610                 <span class="keywordflow">break</span>;
01611         <span class="keywordflow">case</span> DWC_OTG_EP_SPEED_FULL:
01612                 speed = <span class="stringliteral">"FULL"</span>;
01613                 <span class="keywordflow">break</span>;
01614         <span class="keywordflow">case</span> DWC_OTG_EP_SPEED_LOW:
01615                 speed = <span class="stringliteral">"LOW"</span>;
01616                 <span class="keywordflow">break</span>;
01617         <span class="keywordflow">default</span>:
01618                 speed = <span class="stringliteral">"UNKNOWN"</span>;
01619                 <span class="keywordflow">break</span>;
01620         };
01621 
01622         DWC_ERROR(<span class="stringliteral">"  Speed: %s\n"</span>, speed);
01623 
01624         DWC_ERROR(<span class="stringliteral">"  Max packet size: %d\n"</span>,
01625                   dwc_otg_hcd_get_mps(&amp;urb-&gt;pipe_info));
01626         DWC_ERROR(<span class="stringliteral">"  Data buffer length: %d\n"</span>, urb-&gt;length);
01627         DWC_ERROR(<span class="stringliteral">"  Transfer buffer: %p, Transfer DMA: %p\n"</span>,
01628                   urb-&gt;buf, (<span class="keywordtype">void</span> *)urb-&gt;dma);
01629         DWC_ERROR(<span class="stringliteral">"  Setup buffer: %p, Setup DMA: %p\n"</span>,
01630                   urb-&gt;setup_packet, (<span class="keywordtype">void</span> *)urb-&gt;setup_dma);
01631         DWC_ERROR(<span class="stringliteral">"  Interval: %d\n"</span>, urb-&gt;interval);
01632 
01633         <span class="comment">/* Core haltes the channel for Descriptor DMA mode */</span>
01634         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01635                 <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(hcd, hc, hc_regs,
01636                                                DWC_OTG_HC_XFER_AHB_ERR);
01637                 <span class="keywordflow">goto</span> handle_ahberr_done;
01638         }
01639 
01640         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb, -DWC_E_IO);
01641 
01642         <span class="comment">/*</span>
01643 <span class="comment">         * Force a channel halt. Don't call halt_channel because that won't</span>
01644 <span class="comment">         * write to the HCCHARn register in DMA mode to force the halt.</span>
01645 <span class="comment">         */</span>
01646         <a class="code" href="dwc__otg__cil_8h.html#a92">dwc_otg_hc_halt</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc, DWC_OTG_HC_XFER_AHB_ERR);
01647 handle_ahberr_done:
01648         disable_hc_int(hc_regs, ahberr);
01649         <span class="keywordflow">return</span> 1;
01650 }
01651 
<a name="l01656"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a25">01656</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a25">handle_hc_xacterr_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01657                                       <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01658                                       <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01659                                       <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01660 {
01661         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01662                     <span class="stringliteral">"Transaction Error--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01663 
01664         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01665                 <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(hcd, hc, hc_regs,
01666                                                DWC_OTG_HC_XFER_XACT_ERR);
01667                 <span class="keywordflow">goto</span> handle_xacterr_done;
01668         }
01669 
01670         <span class="keywordflow">switch</span> (dwc_otg_hcd_get_pipe_type(&amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;pipe_info)) {
01671         <span class="keywordflow">case</span> UE_CONTROL:
01672         <span class="keywordflow">case</span> UE_BULK:
01673                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
01674                 <span class="keywordflow">if</span> (!hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a>) {
01675 
01676                         update_urb_state_xfer_intr(hc, hc_regs,
01677                                                    qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, qtd,
01678                                                    DWC_OTG_HC_XFER_XACT_ERR);
01679                         dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01680                         <span class="keywordflow">if</span> (!hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a> == DWC_OTG_EP_SPEED_HIGH) {
01681                                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a> = 1;
01682                         }
01683                 }
01684 
01685                 <span class="comment">/*</span>
01686 <span class="comment">                 * Halt the channel so the transfer can be re-started from</span>
01687 <span class="comment">                 * the appropriate point or the PING protocol will start.</span>
01688 <span class="comment">                 */</span>
01689                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_XACT_ERR);
01690                 <span class="keywordflow">break</span>;
01691         <span class="keywordflow">case</span> UE_INTERRUPT:
01692                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
01693                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_11">do_split</a> &amp;&amp; hc-&gt;<a class="code" href="structdwc__hc.html#z34_12">complete_split</a>) {
01694                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a> = 0;
01695                 }
01696                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_XACT_ERR);
01697                 <span class="keywordflow">break</span>;
01698         <span class="keywordflow">case</span> UE_ISOCHRONOUS:
01699                 {
01700                         dwc_otg_halt_status_e halt_status;
01701                         halt_status =
01702                             <a class="code" href="dwc__otg__hcd__intr_8c.html#a10">update_isoc_urb_state</a>(hcd, hc, hc_regs, qtd,
01703                                                   DWC_OTG_HC_XFER_XACT_ERR);
01704 
01705                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, halt_status);
01706                 }
01707                 <span class="keywordflow">break</span>;
01708         }
01709 handle_xacterr_done:
01710         disable_hc_int(hc_regs, xacterr);
01711 
01712         <span class="keywordflow">return</span> 1;
01713 }
01714 
<a name="l01719"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a26">01719</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a26">handle_hc_frmovrun_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01720                                        <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01721                                        <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01722                                        <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01723 {
01724         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01725                     <span class="stringliteral">"Frame Overrun--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01726 
01727         <span class="keywordflow">switch</span> (dwc_otg_hcd_get_pipe_type(&amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;pipe_info)) {
01728         <span class="keywordflow">case</span> UE_CONTROL:
01729         <span class="keywordflow">case</span> UE_BULK:
01730                 <span class="keywordflow">break</span>;
01731         <span class="keywordflow">case</span> UE_INTERRUPT:
01732                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, DWC_OTG_HC_XFER_FRAME_OVERRUN);
01733                 <span class="keywordflow">break</span>;
01734         <span class="keywordflow">case</span> UE_ISOCHRONOUS:
01735                 {
01736                         dwc_otg_halt_status_e halt_status;
01737                         halt_status =
01738                             <a class="code" href="dwc__otg__hcd__intr_8c.html#a10">update_isoc_urb_state</a>(hcd, hc, hc_regs, qtd,
01739                                                   DWC_OTG_HC_XFER_FRAME_OVERRUN);
01740 
01741                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, halt_status);
01742                 }
01743                 <span class="keywordflow">break</span>;
01744         }
01745 
01746         disable_hc_int(hc_regs, frmovrun);
01747 
01748         <span class="keywordflow">return</span> 1;
01749 }
01750 
<a name="l01755"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a27">01755</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a27">handle_hc_datatglerr_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01756                                          <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01757                                          <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01758                                          <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01759 {
01760         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01761                     <span class="stringliteral">"Data Toggle Error--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01762 
01763         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
01764                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01765         } <span class="keywordflow">else</span> {
01766                 DWC_ERROR(<span class="stringliteral">"Data Toggle Error on OUT transfer,"</span>
01767                           <span class="stringliteral">"channel %d\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01768         }
01769 
01770         disable_hc_int(hc_regs, datatglerr);
01771 
01772         <span class="keywordflow">return</span> 1;
01773 }
01774 
01775 <span class="preprocessor">#ifdef DEBUG</span>
01776 <span class="preprocessor"></span>
01782 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">int</span> halt_status_ok(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01783                                  <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01784                                  <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01785                                  <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01786 {
01787         <a class="code" href="unionhcchar__data.html">hcchar_data_t</a> hcchar;
01788         <a class="code" href="unionhctsiz__data.html">hctsiz_data_t</a> hctsiz;
01789         <a class="code" href="unionhcint__data.html">hcint_data_t</a> hcint;
01790         <a class="code" href="unionhcintmsk__data.html">hcintmsk_data_t</a> hcintmsk;
01791         hcsplt_data_t hcsplt;
01792 
01793         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a> == DWC_OTG_HC_XFER_NO_HALT_STATUS) {
01794                 <span class="comment">/*</span>
01795 <span class="comment">                 * This code is here only as a check. This condition should</span>
01796 <span class="comment">                 * never happen. Ignore the halt if it does occur.</span>
01797 <span class="comment">                 */</span>
01798                 hcchar.<a class="code" href="unionhcchar__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o0">hcchar</a>);
01799                 hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o4">hctsiz</a>);
01800                 hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o2">hcint</a>);
01801                 hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o3">hcintmsk</a>);
01802                 hcsplt.<a class="code" href="unionhcintmsk__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o1">hcsplt</a>);
01803                 DWC_WARN
01804                     (<span class="stringliteral">"%s: hc-&gt;halt_status == DWC_OTG_HC_XFER_NO_HALT_STATUS, "</span>
01805                      <span class="stringliteral">"channel %d, hcchar 0x%08x, hctsiz 0x%08x, "</span>
01806                      <span class="stringliteral">"hcint 0x%08x, hcintmsk 0x%08x, "</span>
01807                      <span class="stringliteral">"hcsplt 0x%08x, qtd-&gt;complete_split %d\n"</span>, __func__,
01808                      hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>, hcchar.<a class="code" href="unionhcchar__data.html#o0">d32</a>, hctsiz.<a class="code" href="unionhctsiz__data.html#o0">d32</a>, hcint.<a class="code" href="unionhcint__data.html#o0">d32</a>,
01809                      hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a>, hcsplt.<a class="code" href="unionhcintmsk__data.html#o0">d32</a>, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o2">complete_split</a>);
01810 
01811                 DWC_WARN(<span class="stringliteral">"%s: no halt status, channel %d, ignoring interrupt\n"</span>,
01812                          __func__, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01813                 DWC_WARN(<span class="stringliteral">"\n"</span>);
01814                 clear_hc_int(hc_regs, chhltd);
01815                 <span class="keywordflow">return</span> 0;
01816         }
01817 
01818         <span class="comment">/*</span>
01819 <span class="comment">         * This code is here only as a check. hcchar.chdis should</span>
01820 <span class="comment">         * never be set when the halt interrupt occurs. Halt the</span>
01821 <span class="comment">         * channel again if it does occur.</span>
01822 <span class="comment">         */</span>
01823         hcchar.<a class="code" href="unionhcchar__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o0">hcchar</a>);
01824         <span class="keywordflow">if</span> (hcchar.<a class="code" href="unionhcchar__data.html#o12">b</a>.<a class="code" href="unionhcchar__data.html#o10">chdis</a>) {
01825                 DWC_WARN(<span class="stringliteral">"%s: hcchar.chdis set unexpectedly, "</span>
01826                          <span class="stringliteral">"hcchar 0x%08x, trying to halt again\n"</span>,
01827                          __func__, hcchar.<a class="code" href="unionhcchar__data.html#o0">d32</a>);
01828                 clear_hc_int(hc_regs, chhltd);
01829                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_9">halt_pending</a> = 0;
01830                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd, hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a>);
01831                 <span class="keywordflow">return</span> 0;
01832         }
01833 
01834         <span class="keywordflow">return</span> 1;
01835 }
01836 <span class="preprocessor">#endif</span>
01837 <span class="preprocessor"></span>
<a name="l01842"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a28">01842</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__intr_8c.html#a28">handle_hc_chhltd_intr_dma</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01843                                       <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01844                                       <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01845                                       <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01846 {
01847         <a class="code" href="unionhcint__data.html">hcint_data_t</a> hcint;
01848         <a class="code" href="unionhcintmsk__data.html">hcintmsk_data_t</a> hcintmsk;
01849         <span class="keywordtype">int</span> out_nak_enh = 0;
01850 
01851         <span class="comment">/* For core with OUT NAK enhancement, the flow for high-</span>
01852 <span class="comment">         * speed CONTROL/BULK OUT is handled a little differently.</span>
01853 <span class="comment">         */</span>
01854         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o4">snpsid</a> &gt;= OTG_CORE_REV_2_71a) {
01855                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a> == DWC_OTG_EP_SPEED_HIGH &amp;&amp; !hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> &amp;&amp;
01856                     (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_CONTROL ||
01857                      hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_BULK)) {
01858                         out_nak_enh = 1;
01859                 }
01860         }
01861 
01862         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a> == DWC_OTG_HC_XFER_URB_DEQUEUE ||
01863             (hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a> == DWC_OTG_HC_XFER_AHB_ERR
01864              &amp;&amp; !hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>)) {
01865                 <span class="comment">/*</span>
01866 <span class="comment">                 * Just release the channel. A dequeue can happen on a</span>
01867 <span class="comment">                 * transfer timeout. In the case of an AHB Error, the channel</span>
01868 <span class="comment">                 * was forced to halt because there's no way to gracefully</span>
01869 <span class="comment">                 * recover.</span>
01870 <span class="comment">                 */</span>
01871                 <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>)
01872                         <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(hcd, hc, hc_regs,
01873                                                        hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a>);
01874                 <span class="keywordflow">else</span>
01875                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a>);
01876                 <span class="keywordflow">return</span>;
01877         }
01878 
01879         <span class="comment">/* Read the HCINTn register to determine the cause for the halt. */</span>
01880         hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o2">hcint</a>);
01881         hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o3">hcintmsk</a>);
01882 
01883         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o1">xfercomp</a>) {
01890                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC &amp;&amp; !hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
01891                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a21">handle_hc_ack_intr</a>(hcd, hc, hc_regs, qtd);
01892                 }
01893                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a17">handle_hc_xfercomp_intr</a>(hcd, hc, hc_regs, qtd);
01894         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o4">stall</a>) {
01895                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a18">handle_hc_stall_intr</a>(hcd, hc, hc_regs, qtd);
01896         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o8">xacterr</a> &amp;&amp; !hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01897                 <span class="keywordflow">if</span> (out_nak_enh) {
01898                         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o7">nyet</a> || hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o5">nak</a> || hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o6">ack</a>) {
01899                                 DWC_DEBUG(<span class="stringliteral">"XactErr with NYET/NAK/ACK\n"</span>);
01900                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a> = 0;
01901                         } <span class="keywordflow">else</span> {
01902                                 DWC_DEBUG(<span class="stringliteral">"XactErr without NYET/NAK/ACK\n"</span>);
01903                         }
01904                 }
01905 
01906                 <span class="comment">/*</span>
01907 <span class="comment">                 * Must handle xacterr before nak or ack. Could get a xacterr</span>
01908 <span class="comment">                 * at the same time as either of these on a BULK/CONTROL OUT</span>
01909 <span class="comment">                 * that started with a PING. The xacterr takes precedence.</span>
01910 <span class="comment">                 */</span>
01911                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a25">handle_hc_xacterr_intr</a>(hcd, hc, hc_regs, qtd);
01912         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o13">xcs_xact</a> &amp;&amp; hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01913                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a25">handle_hc_xacterr_intr</a>(hcd, hc, hc_regs, qtd);
01914         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o3">ahberr</a> &amp;&amp; hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o15">dma_desc_enable</a>) {
01915                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a24">handle_hc_ahberr_intr</a>(hcd, hc, hc_regs, qtd);
01916         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o9">bblerr</a>) {
01917                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a23">handle_hc_babble_intr</a>(hcd, hc, hc_regs, qtd);
01918         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o10">frmovrun</a>) {
01919                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a26">handle_hc_frmovrun_intr</a>(hcd, hc, hc_regs, qtd);
01920         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!out_nak_enh) {
01921                 <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o7">nyet</a>) {
01922                         <span class="comment">/*</span>
01923 <span class="comment">                         * Must handle nyet before nak or ack. Could get a nyet at the</span>
01924 <span class="comment">                         * same time as either of those on a BULK/CONTROL OUT that</span>
01925 <span class="comment">                         * started with a PING. The nyet takes precedence.</span>
01926 <span class="comment">                         */</span>
01927                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a22">handle_hc_nyet_intr</a>(hcd, hc, hc_regs, qtd);
01928                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o5">nak</a> &amp;&amp; !hcintmsk.<a class="code" href="unionhcintmsk__data.html#o16">b</a>.<a class="code" href="unionhcintmsk__data.html#o5">nak</a>) {
01929                         <span class="comment">/*</span>
01930 <span class="comment">                         * If nak is not masked, it's because a non-split IN transfer</span>
01931 <span class="comment">                         * is in an error state. In that case, the nak is handled by</span>
01932 <span class="comment">                         * the nak interrupt handler, not here. Handle nak here for</span>
01933 <span class="comment">                         * BULK/CONTROL OUT transfers, which halt on a NAK to allow</span>
01934 <span class="comment">                         * rewinding the buffer pointer.</span>
01935 <span class="comment">                         */</span>
01936                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a20">handle_hc_nak_intr</a>(hcd, hc, hc_regs, qtd);
01937                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o6">ack</a> &amp;&amp; !hcintmsk.<a class="code" href="unionhcintmsk__data.html#o16">b</a>.<a class="code" href="unionhcintmsk__data.html#o6">ack</a>) {
01938                         <span class="comment">/*</span>
01939 <span class="comment">                         * If ack is not masked, it's because a non-split IN transfer</span>
01940 <span class="comment">                         * is in an error state. In that case, the ack is handled by</span>
01941 <span class="comment">                         * the ack interrupt handler, not here. Handle ack here for</span>
01942 <span class="comment">                         * split transfers. Start splits halt on ACK.</span>
01943 <span class="comment">                         */</span>
01944                         <a class="code" href="dwc__otg__hcd__intr_8c.html#a21">handle_hc_ack_intr</a>(hcd, hc, hc_regs, qtd);
01945                 } <span class="keywordflow">else</span> {
01946                         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_INTR ||
01947                             hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC) {
01948                                 <span class="comment">/*</span>
01949 <span class="comment">                                 * A periodic transfer halted with no other channel</span>
01950 <span class="comment">                                 * interrupts set. Assume it was halted by the core</span>
01951 <span class="comment">                                 * because it could not be completed in its scheduled</span>
01952 <span class="comment">                                 * (micro)frame.</span>
01953 <span class="comment">                                 */</span>
01954 <span class="preprocessor">#ifdef DEBUG</span>
01955 <span class="preprocessor"></span>                                DWC_PRINTF
01956                                     (<span class="stringliteral">"%s: Halt channel %d (assume incomplete periodic transfer)\n"</span>,
01957                                      __func__, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01958 <span class="preprocessor">#endif</span>
01959 <span class="preprocessor"></span>                                <a class="code" href="dwc__otg__hcd__intr_8c.html#a13">halt_channel</a>(hcd, hc, qtd,
01960                                              DWC_OTG_HC_XFER_PERIODIC_INCOMPLETE);
01961                         } <span class="keywordflow">else</span> {
01962                                 DWC_ERROR
01963                                     (<span class="stringliteral">"%s: Channel %d, DMA Mode -- ChHltd set, but reason "</span>
01964                                      <span class="stringliteral">"for halting is unknown, hcint 0x%08x, intsts 0x%08x\n"</span>,
01965                                      __func__, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>, hcint.<a class="code" href="unionhcint__data.html#o0">d32</a>,
01966                                      DWC_READ_REG32(&amp;hcd-&gt;
01967                                                     core_if-&gt;core_global_regs-&gt;
01968                                                     gintsts));
01969                         }
01970 
01971                 }
01972         } <span class="keywordflow">else</span> {
01973                 DWC_PRINTF(<span class="stringliteral">"NYET/NAK/ACK/other in non-error case, 0x%08x\n"</span>,
01974                            hcint.<a class="code" href="unionhcint__data.html#o0">d32</a>);
01975         }
01976 }
01977 
<a name="l01989"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a29">01989</a> <span class="keyword">static</span> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a29">handle_hc_chhltd_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01990                                      <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01991                                      <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01992                                      <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd)
01993 {
01994         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"--Host Channel %d Interrupt: "</span>
01995                     <span class="stringliteral">"Channel Halted--\n"</span>, hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
01996 
01997         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a>) {
01998                 <a class="code" href="dwc__otg__hcd__intr_8c.html#a28">handle_hc_chhltd_intr_dma</a>(hcd, hc, hc_regs, qtd);
01999         } <span class="keywordflow">else</span> {
02000 <span class="preprocessor">#ifdef DEBUG</span>
02001 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (!halt_status_ok(hcd, hc, hc_regs, qtd)) {
02002                         <span class="keywordflow">return</span> 1;
02003                 }
02004 <span class="preprocessor">#endif</span>
02005 <span class="preprocessor"></span>                <a class="code" href="dwc__otg__hcd__intr_8c.html#a12">release_channel</a>(hcd, hc, qtd, hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a>);
02006         }
02007 
02008         <span class="keywordflow">return</span> 1;
02009 }
02010 
<a name="l02012"></a><a class="code" href="dwc__otg__hcd__intr_8c.html#a30">02012</a> int32_t <a class="code" href="dwc__otg__hcd__intr_8c.html#a30">dwc_otg_hcd_handle_hc_n_intr</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>, uint32_t num)
02013 {
02014         <span class="keywordtype">int</span> retval = 0;
02015         <a class="code" href="unionhcint__data.html">hcint_data_t</a> hcint;
02016         <a class="code" href="unionhcintmsk__data.html">hcintmsk_data_t</a> hcintmsk;
02017         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> *hc;
02018         <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> *hc_regs;
02019         <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> *qtd;
02020 
02021         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>, <span class="stringliteral">"--Host Channel Interrupt--, Channel %d\n"</span>, num);
02022 
02023         hc = dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o17">hc_ptr_array</a>[num];
02024         hc_regs = dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o2">hc_regs</a>[num];
02025         qtd = DWC_CIRCLEQ_FIRST(&amp;hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>);
02026 
02027         hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o2">hcint</a>);
02028         hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o3">hcintmsk</a>);
02029         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a>,
02030                     <span class="stringliteral">"  hcint 0x%08x, hcintmsk 0x%08x, hcint&amp;hcintmsk 0x%08x\n"</span>,
02031                     hcint.<a class="code" href="unionhcint__data.html#o0">d32</a>, hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a>, (hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> &amp; hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a>));
02032         hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> = hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> &amp; hcintmsk.<a class="code" href="unionhcintmsk__data.html#o0">d32</a>;
02033 
02034         <span class="keywordflow">if</span> (!dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o14">dma_enable</a>) {
02035                 <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o2">chhltd</a> &amp;&amp; hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> != 0x2) {
02036                         hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o2">chhltd</a> = 0;
02037                 }
02038         }
02039 
02040         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o1">xfercomp</a>) {
02041                 retval |=
02042                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a17">handle_hc_xfercomp_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02043                 <span class="comment">/*</span>
02044 <span class="comment">                 * If NYET occurred at same time as Xfer Complete, the NYET is</span>
02045 <span class="comment">                 * handled by the Xfer Complete interrupt handler. Don't want</span>
02046 <span class="comment">                 * to call the NYET interrupt handler in this case.</span>
02047 <span class="comment">                 */</span>
02048                 hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o7">nyet</a> = 0;
02049         }
02050         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o2">chhltd</a>) {
02051                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a29">handle_hc_chhltd_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02052         }
02053         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o3">ahberr</a>) {
02054                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a24">handle_hc_ahberr_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02055         }
02056         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o4">stall</a>) {
02057                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a18">handle_hc_stall_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02058         }
02059         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o5">nak</a>) {
02060                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a20">handle_hc_nak_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02061         }
02062         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o6">ack</a>) {
02063                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a21">handle_hc_ack_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02064         }
02065         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o7">nyet</a>) {
02066                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a22">handle_hc_nyet_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02067         }
02068         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o8">xacterr</a>) {
02069                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a25">handle_hc_xacterr_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02070         }
02071         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o9">bblerr</a>) {
02072                 retval |= <a class="code" href="dwc__otg__hcd__intr_8c.html#a23">handle_hc_babble_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02073         }
02074         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o10">frmovrun</a>) {
02075                 retval |=
02076                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a26">handle_hc_frmovrun_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02077         }
02078         <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o11">datatglerr</a>) {
02079                 retval |=
02080                     <a class="code" href="dwc__otg__hcd__intr_8c.html#a27">handle_hc_datatglerr_intr</a>(dwc_otg_hcd, hc, hc_regs, qtd);
02081         }
02082 
02083         <span class="keywordflow">return</span> retval;
02084 }
02085 
02086 <span class="preprocessor">#endif </span><span class="comment">/* DWC_DEVICE_ONLY */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 27 03:56:37 2011 for DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>

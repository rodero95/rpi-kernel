<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver: dwc_otg_pcd_linux.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>dwc_otg_pcd_linux.c</h1><a href="dwc__otg__pcd__linux_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001  <span class="comment">/* ==========================================================================</span>
00002 <span class="comment">  * $File: //dwh/usb_iip/dev/software/otg/linux/drivers/dwc_otg_pcd_linux.c $</span>
00003 <span class="comment">  * $Revision: #19 $</span>
00004 <span class="comment">  * $Date: 2011/10/26 $</span>
00005 <span class="comment">  * $Change: 1873028 $</span>
00006 <span class="comment">  *</span>
00007 <span class="comment">  * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,</span>
00008 <span class="comment">  * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless</span>
00009 <span class="comment">  * otherwise expressly agreed to in writing between Synopsys and you.</span>
00010 <span class="comment">  *</span>
00011 <span class="comment">  * The Software IS NOT an item of Licensed Software or Licensed Product under</span>
00012 <span class="comment">  * any End User Software License Agreement or Agreement for Licensed Product</span>
00013 <span class="comment">  * with Synopsys or any supplement thereto. You are permitted to use and</span>
00014 <span class="comment">  * redistribute this Software in source and binary forms, with or without</span>
00015 <span class="comment">  * modification, provided that redistributions of source code must retain this</span>
00016 <span class="comment">  * notice. You may not view, use, disclose, copy or distribute this file or</span>
00017 <span class="comment">  * any information contained herein except pursuant to this license grant from</span>
00018 <span class="comment">  * Synopsys. If you do not agree with this notice, including the disclaimer</span>
00019 <span class="comment">  * below, then you are not authorized to use the Software.</span>
00020 <span class="comment">  *</span>
00021 <span class="comment">  * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS</span>
00022 <span class="comment">  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00023 <span class="comment">  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
00024 <span class="comment">  * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,</span>
00025 <span class="comment">  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
00026 <span class="comment">  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
00027 <span class="comment">  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
00028 <span class="comment">  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
00029 <span class="comment">  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
00030 <span class="comment">  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
00031 <span class="comment">  * DAMAGE.</span>
00032 <span class="comment">  * ========================================================================== */</span>
00033 <span class="preprocessor">#ifndef DWC_HOST_ONLY</span>
00034 <span class="preprocessor"></span>
00056 <span class="preprocessor">#include "<a class="code" href="dwc__otg__os__dep_8h.html">dwc_otg_os_dep.h</a>"</span>
00057 <span class="preprocessor">#include "<a class="code" href="dwc__otg__pcd__if_8h.html">dwc_otg_pcd_if.h</a>"</span>
00058 <span class="preprocessor">#include "<a class="code" href="dwc__otg__pcd_8h.html">dwc_otg_pcd.h</a>"</span>
00059 <span class="preprocessor">#include "<a class="code" href="dwc__otg__driver_8h.html">dwc_otg_driver.h</a>"</span>
00060 <span class="preprocessor">#include "<a class="code" href="dwc__otg__dbg_8h.html">dwc_otg_dbg.h</a>"</span>
00061 
00062 <span class="keyword">static</span> <span class="keyword">struct </span>gadget_wrapper {
00063         <a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd;
00064 
00065         <span class="keyword">struct </span>usb_gadget gadget;
00066         <span class="keyword">struct </span>usb_gadget_driver *driver;
00067 
00068         <span class="keyword">struct </span>usb_ep ep0;
00069         <span class="keyword">struct </span>usb_ep in_ep[16];
00070         <span class="keyword">struct </span>usb_ep out_ep[16];
00071 
00072 } *gadget_wrapper;
00073 
00074 <span class="comment">/* Display the contents of the buffer */</span>
00075 <span class="keyword">extern</span> <span class="keywordtype">void</span> dump_msg(<span class="keyword">const</span> u8 * buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> length);
<a name="l00080"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a5">00080</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep</a> *<a class="code" href="dwc__otg__pcd__linux_8c.html#a5">ep_from_handle</a>(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, <span class="keywordtype">void</span> *handle)
00081 {
00082         <span class="keywordtype">int</span> i;
00083         <span class="keywordflow">if</span> (pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o17">ep0</a>.<a class="code" href="structdwc__otg__pcd__ep.html#o9">priv</a> == handle) {
00084                 <span class="keywordflow">return</span> &amp;pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o17">ep0</a>;
00085         }
00086 
00087         <span class="keywordflow">for</span> (i = 0; i &lt; <a class="code" href="dwc__otg__core__if_8h.html#a3">MAX_EPS_CHANNELS</a> - 1; i++) {
00088                 <span class="keywordflow">if</span> (pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o18">in_ep</a>[i].<a class="code" href="structdwc__otg__pcd__ep.html#o9">priv</a> == handle)
00089                         <span class="keywordflow">return</span> &amp;pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o18">in_ep</a>[i];
00090                 <span class="keywordflow">if</span> (pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o19">out_ep</a>[i].<a class="code" href="structdwc__otg__pcd__ep.html#o9">priv</a> == handle)
00091                         <span class="keywordflow">return</span> &amp;pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o19">out_ep</a>[i];
00092         }
00093 
00094         <span class="keywordflow">return</span> NULL;
00095 }
00096 
00097 <span class="comment">/* USB Endpoint Operations */</span>
00098 <span class="comment">/*</span>
00099 <span class="comment"> * The following sections briefly describe the behavior of the Gadget</span>
00100 <span class="comment"> * API endpoint operations implemented in the DWC_otg driver</span>
00101 <span class="comment"> * software. Detailed descriptions of the generic behavior of each of</span>
00102 <span class="comment"> * these functions can be found in the Linux header file</span>
00103 <span class="comment"> * include/linux/usb_gadget.h.</span>
00104 <span class="comment"> *</span>
00105 <span class="comment"> * The Gadget API provides wrapper functions for each of the function</span>
00106 <span class="comment"> * pointers defined in usb_ep_ops. The Gadget Driver calls the wrapper</span>
00107 <span class="comment"> * function, which then calls the underlying PCD function. The</span>
00108 <span class="comment"> * following sections are named according to the wrapper</span>
00109 <span class="comment"> * functions. Within each section, the corresponding DWC_otg PCD</span>
00110 <span class="comment"> * function name is specified.</span>
00111 <span class="comment"> *</span>
00112 <span class="comment"> */</span>
00113 
<a name="l00121"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a6">00121</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a6">ep_enable</a>(<span class="keyword">struct</span> usb_ep *usb_ep,
00122                      <span class="keyword">const</span> <span class="keyword">struct</span> usb_endpoint_descriptor *ep_desc)
00123 {
00124         <span class="keywordtype">int</span> retval;
00125 
00126         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p,%p)\n"</span>, __func__, usb_ep, ep_desc);
00127 
00128         <span class="keywordflow">if</span> (!usb_ep || !ep_desc || ep_desc-&gt;bDescriptorType != USB_DT_ENDPOINT) {
00129                 DWC_WARN(<span class="stringliteral">"%s, bad ep or descriptor\n"</span>, __func__);
00130                 <span class="keywordflow">return</span> -EINVAL;
00131         }
00132         <span class="keywordflow">if</span> (usb_ep == &amp;gadget_wrapper-&gt;ep0) {
00133                 DWC_WARN(<span class="stringliteral">"%s, bad ep(0)\n"</span>, __func__);
00134                 <span class="keywordflow">return</span> -EINVAL;
00135         }
00136 
00137         <span class="comment">/* Check FIFO size? */</span>
00138         <span class="keywordflow">if</span> (!ep_desc-&gt;wMaxPacketSize) {
00139                 DWC_WARN(<span class="stringliteral">"%s, bad %s maxpacket\n"</span>, __func__, usb_ep-&gt;name);
00140                 <span class="keywordflow">return</span> -ERANGE;
00141         }
00142 
00143         <span class="keywordflow">if</span> (!gadget_wrapper-&gt;driver ||
00144             gadget_wrapper-&gt;gadget.speed == USB_SPEED_UNKNOWN) {
00145                 DWC_WARN(<span class="stringliteral">"%s, bogus device state\n"</span>, __func__);
00146                 <span class="keywordflow">return</span> -ESHUTDOWN;
00147         }
00148 
00149         <span class="comment">/* Delete after check - MAS */</span>
00150 <span class="preprocessor">#if 0</span>
00151 <span class="preprocessor"></span>        nat = (uint32_t) ep_desc-&gt;wMaxPacketSize;
00152         printk(KERN_ALERT <span class="stringliteral">"%s: nat (before) =%d\n"</span>, __func__, nat);
00153         nat = (nat &gt;&gt; 11) &amp; 0x03;
00154         printk(KERN_ALERT <span class="stringliteral">"%s: nat (after) =%d\n"</span>, __func__, nat);
00155 <span class="preprocessor">#endif</span>
00156 <span class="preprocessor"></span>        retval = <a class="code" href="dwc__otg__pcd__if_8h.html#a19">dwc_otg_pcd_ep_enable</a>(gadget_wrapper-&gt;pcd,
00157                                        (<span class="keyword">const</span> uint8_t *)ep_desc,
00158                                        (<span class="keywordtype">void</span> *)usb_ep);
00159         <span class="keywordflow">if</span> (retval) {
00160                 DWC_WARN(<span class="stringliteral">"dwc_otg_pcd_ep_enable failed\n"</span>);
00161                 <span class="keywordflow">return</span> -EINVAL;
00162         }
00163 
00164         usb_ep-&gt;maxpacket = le16_to_cpu(ep_desc-&gt;wMaxPacketSize);
00165 
00166         <span class="keywordflow">return</span> 0;
00167 }
00168 
<a name="l00177"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a7">00177</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a7">ep_disable</a>(<span class="keyword">struct</span> usb_ep *usb_ep)
00178 {
00179         <span class="keywordtype">int</span> retval;
00180 
00181         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p)\n"</span>, __func__, usb_ep);
00182         <span class="keywordflow">if</span> (!usb_ep) {
00183                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a2">DBG_PCD</a>, <span class="stringliteral">"%s, %s not enabled\n"</span>, __func__,
00184                             usb_ep ? usb_ep-&gt;name : NULL);
00185                 <span class="keywordflow">return</span> -EINVAL;
00186         }
00187 
00188         retval = <a class="code" href="dwc__otg__pcd__if_8h.html#a20">dwc_otg_pcd_ep_disable</a>(gadget_wrapper-&gt;pcd, usb_ep);
00189         <span class="keywordflow">if</span> (retval) {
00190                 retval = -EINVAL;
00191         }
00192 
00193         <span class="keywordflow">return</span> retval;
00194 }
00195 
<a name="l00203"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a8">00203</a> <span class="keyword">static</span> <span class="keyword">struct </span>usb_request *<a class="code" href="dwc__otg__pcd__linux_8c.html#a8">dwc_otg_pcd_alloc_request</a>(<span class="keyword">struct</span> usb_ep *ep,
00204                                                      gfp_t gfp_flags)
00205 {
00206         <span class="keyword">struct </span>usb_request *usb_req;
00207 
00208         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p,%d)\n"</span>, __func__, ep, gfp_flags);
00209         <span class="keywordflow">if</span> (0 == ep) {
00210                 DWC_WARN(<span class="stringliteral">"%s() %s\n"</span>, __func__, <span class="stringliteral">"Invalid EP!\n"</span>);
00211                 <span class="keywordflow">return</span> 0;
00212         }
00213         usb_req = kmalloc(<span class="keyword">sizeof</span>(*usb_req), gfp_flags);
00214         <span class="keywordflow">if</span> (0 == usb_req) {
00215                 DWC_WARN(<span class="stringliteral">"%s() %s\n"</span>, __func__, <span class="stringliteral">"request allocation failed!\n"</span>);
00216                 <span class="keywordflow">return</span> 0;
00217         }
00218         memset(usb_req, 0, <span class="keyword">sizeof</span>(*usb_req));
00219         usb_req-&gt;<a class="code" href="structdwc__otg__pcd__ep.html#o4">dma</a> = DWC_DMA_ADDR_INVALID;
00220 
00221         <span class="keywordflow">return</span> usb_req;
00222 }
00223 
<a name="l00230"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a9">00230</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a9">dwc_otg_pcd_free_request</a>(<span class="keyword">struct</span> usb_ep *ep, <span class="keyword">struct</span> usb_request *req)
00231 {
00232         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p,%p)\n"</span>, __func__, ep, req);
00233 
00234         <span class="keywordflow">if</span> (0 == ep || 0 == req) {
00235                 DWC_WARN(<span class="stringliteral">"%s() %s\n"</span>, __func__,
00236                          <span class="stringliteral">"Invalid ep or req argument!\n"</span>);
00237                 <span class="keywordflow">return</span>;
00238         }
00239 
00240         kfree(req);
00241 }
00242 
00243 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00244 <span class="preprocessor"></span>
00254 <span class="keyword">static</span> <span class="keywordtype">void</span> *dwc_otg_pcd_alloc_buffer(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keywordtype">unsigned</span> bytes,
00255                                       dma_addr_t * dma, gfp_t gfp_flags)
00256 {
00257         <span class="keywordtype">void</span> *buf;
00258         <a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd = 0;
00259 
00260         pcd = gadget_wrapper-&gt;pcd;
00261 
00262         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_PCDV, <span class="stringliteral">"%s(%p,%d,%p,%0x)\n"</span>, __func__, usb_ep, bytes,
00263                     dma, gfp_flags);
00264 
00265         <span class="comment">/* Check dword alignment */</span>
00266         <span class="keywordflow">if</span> ((bytes &amp; 0x3UL) != 0) {
00267                 DWC_WARN(<span class="stringliteral">"%s() Buffer size is not a multiple of"</span>
00268                          <span class="stringliteral">"DWORD size (%d)"</span>, __func__, bytes);
00269         }
00270 
00271         buf = dma_alloc_coherent(NULL, bytes, dma, gfp_flags);
00272 
00273         <span class="comment">/* Check dword alignment */</span>
00274         <span class="keywordflow">if</span> (((int)buf &amp; 0x3UL) != 0) {
00275                 DWC_WARN(<span class="stringliteral">"%s() Buffer is not DWORD aligned (%p)"</span>,
00276                          __func__, buf);
00277         }
00278 
00279         <span class="keywordflow">return</span> buf;
00280 }
00281 
00290 <span class="keyword">static</span> <span class="keywordtype">void</span> dwc_otg_pcd_free_buffer(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keywordtype">void</span> *buf,
00291                                     dma_addr_t dma, <span class="keywordtype">unsigned</span> bytes)
00292 {
00293         <a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd = 0;
00294 
00295         pcd = gadget_wrapper-&gt;pcd;
00296 
00297         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_PCDV, <span class="stringliteral">"%s(%p,%0x,%d)\n"</span>, __func__, buf, dma, bytes);
00298 
00299         dma_free_coherent(NULL, bytes, buf, dma);
00300 }
00301 <span class="preprocessor">#endif</span>
00302 <span class="preprocessor"></span>
<a name="l00317"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a10">00317</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a10">ep_queue</a>(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keyword">struct</span> usb_request *usb_req,
00318                     gfp_t gfp_flags)
00319 {
00320         <a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd;
00321         <span class="keyword">struct </span><a class="code" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep</a> *ep = NULL;
00322         <span class="keywordtype">int</span> retval = 0, is_isoc_ep = 0;
00323         dma_addr_t dma_addr = DWC_DMA_ADDR_INVALID;
00324 
00325         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p,%p,%d)\n"</span>,
00326                     __func__, usb_ep, usb_req, gfp_flags);
00327 
00328         <span class="keywordflow">if</span> (!usb_req || !usb_req-&gt;complete || !usb_req-&gt;buf) {
00329                 DWC_WARN(<span class="stringliteral">"bad params\n"</span>);
00330                 <span class="keywordflow">return</span> -EINVAL;
00331         }
00332 
00333         <span class="keywordflow">if</span> (!usb_ep) {
00334                 DWC_WARN(<span class="stringliteral">"bad ep\n"</span>);
00335                 <span class="keywordflow">return</span> -EINVAL;
00336         }
00337 
00338         pcd = gadget_wrapper-&gt;pcd;
00339         <span class="keywordflow">if</span> (!gadget_wrapper-&gt;driver ||
00340             gadget_wrapper-&gt;gadget.speed == USB_SPEED_UNKNOWN) {
00341                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"gadget.speed=%d\n"</span>,
00342                             gadget_wrapper-&gt;gadget.speed);
00343                 DWC_WARN(<span class="stringliteral">"bogus device state\n"</span>);
00344                 <span class="keywordflow">return</span> -ESHUTDOWN;
00345         }
00346 
00347         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a2">DBG_PCD</a>, <span class="stringliteral">"%s queue req %p, len %d buf %p\n"</span>,
00348                     usb_ep-&gt;name, usb_req, usb_req-&gt;length, usb_req-&gt;buf);
00349 
00350         usb_req-&gt;status = -EINPROGRESS;
00351         usb_req-&gt;actual = 0;
00352 
00353         ep = <a class="code" href="dwc__otg__pcd__linux_8c.html#a5">ep_from_handle</a>(pcd, usb_ep);
00354         <span class="keywordflow">if</span> (ep == NULL)
00355                 is_isoc_ep = 0;
00356         <span class="keywordflow">else</span>
00357                 is_isoc_ep = (ep-&gt;<a class="code" href="structdwc__otg__pcd__ep.html#o7">dwc_ep</a>.<a class="code" href="structdwc__ep.html#o4">type</a> == DWC_OTG_EP_TYPE_ISOC) ? 1 : 0;
00358 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00359 <span class="preprocessor"></span>        dma_addr = usb_req-&gt;<a class="code" href="structdwc__otg__pcd__ep.html#o4">dma</a>;
00360 <span class="preprocessor">#else</span>
00361 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__pcd_8h.html#a3">GET_CORE_IF</a>(pcd)-&gt;dma_enable) {
00362                 <span class="keyword">struct </span>pci_dev *dev = gadget_wrapper-&gt;<a class="code" href="structdwc__otg__pcd__ep.html#o8">pcd</a>-&gt;<a class="code" href="structdwc__otg__pcd.html#o1">otg_dev</a>-&gt;<a class="code" href="structdwc__otg__device.html#o0">os_dep</a>.pcidev;
00363                 <span class="keywordflow">if</span> (usb_req-&gt;length != 0 &amp;&amp; usb_req-&gt;dma == DWC_DMA_ADDR_INVALID) {
00364                         dma_addr = pci_map_single(dev, usb_req-&gt;buf, usb_req-&gt;length, 
00365                                         ep-&gt;<a class="code" href="structdwc__otg__pcd__ep.html#o7">dwc_ep</a>.<a class="code" href="structdwc__ep.html#o1">is_in</a> ? PCI_DMA_TODEVICE : PCI_DMA_FROMDEVICE);
00366                 }
00367         }
00368 <span class="preprocessor">#endif</span>
00369 <span class="preprocessor"></span>
00370 <span class="preprocessor">#ifdef DWC_UTE_PER_IO</span>
00371 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (is_isoc_ep == 1) {
00372                 retval = dwc_otg_pcd_xiso_ep_queue(pcd, usb_ep, usb_req-&gt;buf, dma_addr,
00373                         usb_req-&gt;length, usb_req-&gt;zero, usb_req,
00374                         gfp_flags == GFP_ATOMIC ? 1 : 0, &amp;usb_req-&gt;ext_req);
00375                 <span class="keywordflow">if</span> (retval)
00376                         <span class="keywordflow">return</span> -EINVAL;
00377 
00378                 <span class="keywordflow">return</span> 0;
00379         }
00380 <span class="preprocessor">#endif</span>
00381 <span class="preprocessor"></span>        retval = <a class="code" href="dwc__otg__pcd__if_8h.html#a21">dwc_otg_pcd_ep_queue</a>(pcd, usb_ep, usb_req-&gt;buf, dma_addr,
00382                                       usb_req-&gt;length, usb_req-&gt;zero, usb_req,
00383                                       gfp_flags == GFP_ATOMIC ? 1 : 0);
00384         <span class="keywordflow">if</span> (retval) {
00385                 <span class="keywordflow">return</span> -EINVAL;
00386         }
00387 
00388         <span class="keywordflow">return</span> 0;
00389 }
00390 
<a name="l00394"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a11">00394</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a11">ep_dequeue</a>(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keyword">struct</span> usb_request *usb_req)
00395 {
00396         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p,%p)\n"</span>, __func__, usb_ep, usb_req);
00397 
00398         <span class="keywordflow">if</span> (!usb_ep || !usb_req) {
00399                 DWC_WARN(<span class="stringliteral">"bad argument\n"</span>);
00400                 <span class="keywordflow">return</span> -EINVAL;
00401         }
00402         <span class="keywordflow">if</span> (!gadget_wrapper-&gt;driver ||
00403             gadget_wrapper-&gt;gadget.speed == USB_SPEED_UNKNOWN) {
00404                 DWC_WARN(<span class="stringliteral">"bogus device state\n"</span>);
00405                 <span class="keywordflow">return</span> -ESHUTDOWN;
00406         }
00407         <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__pcd__if_8h.html#a22">dwc_otg_pcd_ep_dequeue</a>(gadget_wrapper-&gt;pcd, usb_ep, usb_req)) {
00408                 <span class="keywordflow">return</span> -EINVAL;
00409         }
00410 
00411         <span class="keywordflow">return</span> 0;
00412 }
00413 
<a name="l00430"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a12">00430</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a12">ep_halt</a>(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keywordtype">int</span> value)
00431 {
00432         <span class="keywordtype">int</span> retval = 0;
00433 
00434         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a2">DBG_PCD</a>, <span class="stringliteral">"HALT %s %d\n"</span>, usb_ep-&gt;name, value);
00435 
00436         <span class="keywordflow">if</span> (!usb_ep) {
00437                 DWC_WARN(<span class="stringliteral">"bad ep\n"</span>);
00438                 <span class="keywordflow">return</span> -EINVAL;
00439         }
00440 
00441         retval = <a class="code" href="dwc__otg__pcd__if_8h.html#a23">dwc_otg_pcd_ep_halt</a>(gadget_wrapper-&gt;pcd, usb_ep, value);
00442         <span class="keywordflow">if</span> (retval == -DWC_E_AGAIN) {
00443                 <span class="keywordflow">return</span> -EAGAIN;
00444         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (retval) {
00445                 retval = -EINVAL;
00446         }
00447 
00448         <span class="keywordflow">return</span> retval;
00449 }
00450 
00451 <span class="preprocessor">#ifdef DWC_EN_ISOC</span>
00452 <span class="preprocessor"></span>
<a name="l00461"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a13">00461</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a13">iso_ep_start</a>(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keyword">struct</span> usb_iso_request *req,
00462                         gfp_t gfp_flags)
00463 {
00464         <span class="keywordtype">int</span> retval = 0;
00465 
00466         <span class="keywordflow">if</span> (!req || !req-&gt;process_buffer || !req-&gt;buf0 || !req-&gt;buf1) {
00467                 DWC_WARN(<span class="stringliteral">"bad params\n"</span>);
00468                 <span class="keywordflow">return</span> -EINVAL;
00469         }
00470 
00471         <span class="keywordflow">if</span> (!usb_ep) {
00472                 DWC_PRINTF(<span class="stringliteral">"bad params\n"</span>);
00473                 <span class="keywordflow">return</span> -EINVAL;
00474         }
00475 
00476         req-&gt;status = -EINPROGRESS;
00477 
00478         retval =
00479             <a class="code" href="dwc__otg__pcd__if_8h.html#a26">dwc_otg_pcd_iso_ep_start</a>(gadget_wrapper-&gt;pcd, usb_ep, req-&gt;buf0,
00480                                      req-&gt;buf1, req-&gt;dma0, req-&gt;dma1,
00481                                      req-&gt;sync_frame, req-&gt;data_pattern_frame,
00482                                      req-&gt;data_per_frame,
00483                                      req-&gt;flags &amp; USB_REQ_ISO_ASAP ? -1 : req-&gt;
00484                                      start_frame, req-&gt;buf_proc_intrvl, req,
00485                                      gfp_flags == GFP_ATOMIC ? 1 : 0);
00486 
00487         <span class="keywordflow">if</span> (retval) {
00488                 <span class="keywordflow">return</span> -EINVAL;
00489         }
00490 
00491         <span class="keywordflow">return</span> retval;
00492 }
00493 
<a name="l00497"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a14">00497</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a14">iso_ep_stop</a>(<span class="keyword">struct</span> usb_ep *usb_ep, <span class="keyword">struct</span> usb_iso_request *req)
00498 {
00499         <span class="keywordtype">int</span> retval = 0;
00500         <span class="keywordflow">if</span> (!usb_ep) {
00501                 DWC_WARN(<span class="stringliteral">"bad ep\n"</span>);
00502         }
00503 
00504         <span class="keywordflow">if</span> (!gadget_wrapper-&gt;driver ||
00505             gadget_wrapper-&gt;gadget.speed == USB_SPEED_UNKNOWN) {
00506                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"gadget.speed=%d\n"</span>,
00507                             gadget_wrapper-&gt;gadget.speed);
00508                 DWC_WARN(<span class="stringliteral">"bogus device state\n"</span>);
00509         }
00510 
00511         <a class="code" href="dwc__otg__pcd__if_8h.html#a27">dwc_otg_pcd_iso_ep_stop</a>(gadget_wrapper-&gt;pcd, usb_ep, req);
00512         <span class="keywordflow">if</span> (retval) {
00513                 retval = -EINVAL;
00514         }
00515 
00516         <span class="keywordflow">return</span> retval;
00517 }
00518 
00519 <span class="keyword">static</span> <span class="keyword">struct </span>usb_iso_request *alloc_iso_request(<span class="keyword">struct</span> usb_ep *ep,
00520                                                  <span class="keywordtype">int</span> packets, gfp_t gfp_flags)
00521 {
00522         <span class="keyword">struct </span>usb_iso_request *pReq = NULL;
00523         uint32_t req_size;
00524 
00525         req_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>usb_iso_request);
00526         req_size +=
00527             (2 * packets * (<span class="keyword">sizeof</span>(<span class="keyword">struct </span>usb_gadget_iso_packet_descriptor)));
00528 
00529         pReq = kmalloc(req_size, gfp_flags);
00530         <span class="keywordflow">if</span> (!pReq) {
00531                 DWC_WARN(<span class="stringliteral">"Can't allocate Iso Request\n"</span>);
00532                 <span class="keywordflow">return</span> 0;
00533         }
00534         pReq-&gt;iso_packet_desc0 = (<span class="keywordtype">void</span> *)(pReq + 1);
00535 
00536         pReq-&gt;iso_packet_desc1 = pReq-&gt;iso_packet_desc0 + packets;
00537 
00538         <span class="keywordflow">return</span> pReq;
00539 }
00540 
00541 <span class="keyword">static</span> <span class="keywordtype">void</span> free_iso_request(<span class="keyword">struct</span> usb_ep *ep, <span class="keyword">struct</span> usb_iso_request *req)
00542 {
00543         kfree(req);
00544 }
00545 
00546 <span class="keyword">static</span> <span class="keyword">struct </span>usb_isoc_ep_ops dwc_otg_pcd_ep_ops = {
00547         .ep_ops = {
00548                    .enable = ep_enable,
00549                    .disable = ep_disable,
00550 
00551                    .alloc_request = dwc_otg_pcd_alloc_request,
00552                    .free_request = dwc_otg_pcd_free_request,
00553 
00554 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00555 <span class="preprocessor"></span>                   .alloc_buffer = dwc_otg_pcd_alloc_buffer,
00556                    .free_buffer = dwc_otg_pcd_free_buffer,
00557 <span class="preprocessor">#endif</span>
00558 <span class="preprocessor"></span>
00559                    .queue = ep_queue,
00560                    .dequeue = ep_dequeue,
00561 
00562                    .set_halt = ep_halt,
00563                    .fifo_status = 0,
00564                    .fifo_flush = 0,
00565                    },
00566         .iso_ep_start = iso_ep_start,
00567         .iso_ep_stop = iso_ep_stop,
00568         .alloc_iso_request = alloc_iso_request,
00569         .free_iso_request = free_iso_request,
00570 };
00571 
00572 <span class="preprocessor">#else</span>
00573 <span class="preprocessor"></span>
00574 <span class="keyword">static</span> <span class="keyword">struct </span>usb_ep_ops dwc_otg_pcd_ep_ops = {
00575         .enable = ep_enable,
00576         .disable = ep_disable,
00577 
00578         .alloc_request = dwc_otg_pcd_alloc_request,
00579         .free_request = dwc_otg_pcd_free_request,
00580 
00581 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00582 <span class="preprocessor"></span>        .alloc_buffer = dwc_otg_pcd_alloc_buffer,
00583         .free_buffer = dwc_otg_pcd_free_buffer,
00584 <span class="preprocessor">#endif</span>
00585 <span class="preprocessor"></span>
00586         .queue = ep_queue,
00587         .dequeue = ep_dequeue,
00588 
00589         .set_halt = ep_halt,
00590         .fifo_status = 0,
00591         .fifo_flush = 0,
00592 
00593 };
00594 
00595 <span class="preprocessor">#endif </span><span class="comment">/* _EN_ISOC_ */</span>
00596 <span class="comment">/*      Gadget Operations */</span>
<a name="l00615"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a17">00615</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a17">get_frame_number</a>(<span class="keyword">struct</span> usb_gadget *gadget)
00616 {
00617         <span class="keyword">struct </span>gadget_wrapper *d;
00618 
00619         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p)\n"</span>, __func__, gadget);
00620 
00621         <span class="keywordflow">if</span> (gadget == 0) {
00622                 <span class="keywordflow">return</span> -ENODEV;
00623         }
00624 
00625         d = container_of(gadget, <span class="keyword">struct</span> gadget_wrapper, gadget);
00626         <span class="keywordflow">return</span> <a class="code" href="dwc__otg__pcd__if_8h.html#a25">dwc_otg_pcd_get_frame_number</a>(d-&gt;pcd);
00627 }
00628 
00629 <span class="preprocessor">#ifdef CONFIG_USB_DWC_OTG_LPM</span>
00630 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> test_lpm_enabled(<span class="keyword">struct</span> usb_gadget *gadget)
00631 {
00632         <span class="keyword">struct </span>gadget_wrapper *d;
00633 
00634         d = container_of(gadget, <span class="keyword">struct</span> gadget_wrapper, gadget);
00635 
00636         <span class="keywordflow">return</span> <a class="code" href="dwc__otg__pcd__if_8h.html#a31">dwc_otg_pcd_is_lpm_enabled</a>(d-&gt;pcd);
00637 }
00638 <span class="preprocessor">#endif</span>
00639 <span class="preprocessor"></span>
<a name="l00646"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a18">00646</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a18">wakeup</a>(<span class="keyword">struct</span> usb_gadget *gadget)
00647 {
00648         <span class="keyword">struct </span>gadget_wrapper *d;
00649 
00650         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p)\n"</span>, __func__, gadget);
00651 
00652         <span class="keywordflow">if</span> (gadget == 0) {
00653                 <span class="keywordflow">return</span> -ENODEV;
00654         } <span class="keywordflow">else</span> {
00655                 d = container_of(gadget, <span class="keyword">struct</span> gadget_wrapper, gadget);
00656         }
00657         <a class="code" href="dwc__otg__pcd__if_8h.html#a30">dwc_otg_pcd_wakeup</a>(d-&gt;pcd);
00658         <span class="keywordflow">return</span> 0;
00659 }
00660 
00661 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>usb_gadget_ops dwc_otg_pcd_ops = {
00662         .get_frame = get_frame_number,
00663         .wakeup = wakeup,
00664 <span class="preprocessor">#ifdef CONFIG_USB_DWC_OTG_LPM</span>
00665 <span class="preprocessor"></span>        .lpm_support = test_lpm_enabled,
00666 <span class="preprocessor">#endif</span>
00667 <span class="preprocessor"></span>        <span class="comment">// current versions must always be self-powered</span>
00668 };
00669 
00670 <span class="keyword">static</span> <span class="keywordtype">int</span> _setup(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, uint8_t * bytes)
00671 {
00672         <span class="keywordtype">int</span> retval = -DWC_E_NOT_SUPPORTED;
00673         <span class="keywordflow">if</span> (gadget_wrapper-&gt;driver &amp;&amp; gadget_wrapper-&gt;driver-&gt;setup) {
00674                 retval = gadget_wrapper-&gt;driver-&gt;setup(&amp;gadget_wrapper-&gt;gadget,
00675                                                        (<span class="keyword">struct</span> usb_ctrlrequest
00676                                                         *)bytes);
00677         }
00678 
00679         <span class="keywordflow">if</span> (retval == -ENOTSUPP) {
00680                 retval = -DWC_E_NOT_SUPPORTED;
00681         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (retval &lt; 0) {
00682                 retval = -DWC_E_INVALID;
00683         }
00684 
00685         <span class="keywordflow">return</span> retval;
00686 }
00687 
00688 <span class="preprocessor">#ifdef DWC_EN_ISOC</span>
00689 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> _isoc_complete(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, <span class="keywordtype">void</span> *ep_handle,
00690                           <span class="keywordtype">void</span> *req_handle, <span class="keywordtype">int</span> proc_buf_num)
00691 {
00692         <span class="keywordtype">int</span> i, packet_count;
00693         <span class="keyword">struct </span>usb_gadget_iso_packet_descriptor *iso_packet = 0;
00694         <span class="keyword">struct </span>usb_iso_request *iso_req = req_handle;
00695 
00696         <span class="keywordflow">if</span> (proc_buf_num) {
00697                 iso_packet = iso_req-&gt;iso_packet_desc1;
00698         } <span class="keywordflow">else</span> {
00699                 iso_packet = iso_req-&gt;iso_packet_desc0;
00700         }
00701         packet_count =
00702             <a class="code" href="dwc__otg__pcd__if_8h.html#a29">dwc_otg_pcd_get_iso_packet_count</a>(pcd, ep_handle, req_handle);
00703         <span class="keywordflow">for</span> (i = 0; i &lt; packet_count; ++i) {
00704                 <span class="keywordtype">int</span> status;
00705                 <span class="keywordtype">int</span> actual;
00706                 <span class="keywordtype">int</span> offset;
00707                 <a class="code" href="dwc__otg__pcd__if_8h.html#a28">dwc_otg_pcd_get_iso_packet_params</a>(pcd, ep_handle, req_handle,
00708                                                   i, &amp;status, &amp;actual, &amp;offset);
00709                 <span class="keywordflow">switch</span> (status) {
00710                 <span class="keywordflow">case</span> -DWC_E_NO_DATA:
00711                         status = -ENODATA;
00712                         <span class="keywordflow">break</span>;
00713                 <span class="keywordflow">default</span>:
00714                         <span class="keywordflow">if</span> (status) {
00715                                 DWC_PRINTF(<span class="stringliteral">"unknown status in isoc packet\n"</span>);
00716                         }
00717 
00718                 }
00719                 iso_packet[i].status = status;
00720                 iso_packet[i].offset = offset;
00721                 iso_packet[i].actual_length = actual;
00722         }
00723 
00724         iso_req-&gt;status = 0;
00725         iso_req-&gt;process_buffer(ep_handle, iso_req);
00726 
00727         <span class="keywordflow">return</span> 0;
00728 }
00729 <span class="preprocessor">#endif </span><span class="comment">/* DWC_EN_ISOC */</span>
00730 
00731 <span class="preprocessor">#ifdef DWC_UTE_PER_IO</span>
00732 <span class="preprocessor"></span>
00744 <span class="keyword">static</span> <span class="keywordtype">int</span> _xisoc_complete(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, <span class="keywordtype">void</span> *ep_handle,
00745                            <span class="keywordtype">void</span> *req_handle, int32_t status, <span class="keywordtype">void</span> *ereq_port)
00746 {
00747         <span class="keyword">struct </span>dwc_ute_iso_req_ext *ereqorg = NULL;
00748         <span class="keyword">struct </span>dwc_iso_xreq_port *ereqport = NULL;
00749         <span class="keyword">struct </span>dwc_ute_iso_packet_descriptor *desc_org = NULL;
00750         <span class="keywordtype">int</span> i;
00751         <span class="keyword">struct </span>usb_request *req;
00752         <span class="comment">//struct dwc_ute_iso_packet_descriptor *</span>
00753         <span class="comment">//int status = 0;</span>
00754 
00755         req = (<span class="keyword">struct </span>usb_request *)req_handle;
00756         ereqorg = &amp;req-&gt;ext_req;
00757         ereqport = (<span class="keyword">struct </span>dwc_iso_xreq_port *)ereq_port;
00758         desc_org = ereqorg-&gt;per_io_frame_descs;
00759 
00760         <span class="keywordflow">if</span> (req &amp;&amp; req-&gt;complete) {
00761                 <span class="comment">/* Copy the request data from the portable logic to our request */</span>
00762                 <span class="keywordflow">for</span> (i = 0; i &lt; ereqport-&gt;pio_pkt_count; i++) {
00763                         desc_org[i].actual_length =
00764                             ereqport-&gt;per_io_frame_descs[i].actual_length;
00765                         desc_org[i].status =
00766                             ereqport-&gt;per_io_frame_descs[i].status;
00767                 }
00768 
00769                 <span class="keywordflow">switch</span> (status) {
00770                 <span class="keywordflow">case</span> -DWC_E_SHUTDOWN:
00771                         req-&gt;status = -ESHUTDOWN;
00772                         <span class="keywordflow">break</span>;
00773                 <span class="keywordflow">case</span> -DWC_E_RESTART:
00774                         req-&gt;status = -ECONNRESET;
00775                         <span class="keywordflow">break</span>;
00776                 <span class="keywordflow">case</span> -DWC_E_INVALID:
00777                         req-&gt;status = -EINVAL;
00778                         <span class="keywordflow">break</span>;
00779                 <span class="keywordflow">case</span> -DWC_E_TIMEOUT:
00780                         req-&gt;status = -ETIMEDOUT;
00781                         <span class="keywordflow">break</span>;
00782                 <span class="keywordflow">default</span>:
00783                         req-&gt;status = status;
00784                 }
00785 
00786                 <span class="comment">/* And call the gadget's completion */</span>
00787                 req-&gt;complete(ep_handle, req);
00788         }
00789 
00790         <span class="keywordflow">return</span> 0;
00791 }
00792 <span class="preprocessor">#endif </span><span class="comment">/* DWC_UTE_PER_IO */</span>
00793 <span class="keyword">static</span> <span class="keywordtype">int</span> _complete(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, <span class="keywordtype">void</span> *ep_handle,
00794                      <span class="keywordtype">void</span> *req_handle, int32_t status, uint32_t actual)
00795 {
00796         <span class="keyword">struct </span>usb_request *req = (<span class="keyword">struct </span>usb_request *)req_handle;
00797 <span class="preprocessor">#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2,6,27)</span>
00798 <span class="preprocessor"></span>        <span class="keyword">struct </span><a class="code" href="structdwc__otg__pcd__ep.html">dwc_otg_pcd_ep</a> *ep = NULL;
00799 <span class="preprocessor">#endif</span>
00800 <span class="preprocessor"></span><span class="preprocessor">#ifdef PCI_INTERFACE</span>
00801 <span class="preprocessor"></span>        <span class="keyword">struct </span>pci_dev *dev = NULL;
00802 <span class="preprocessor">#endif</span>
00803 <span class="preprocessor"></span>
00804         <span class="keywordflow">if</span> (req &amp;&amp; req-&gt;complete) {
00805                 <span class="keywordflow">switch</span> (status) {
00806                 <span class="keywordflow">case</span> -DWC_E_SHUTDOWN:
00807                         req-&gt;status = -ESHUTDOWN;
00808                         <span class="keywordflow">break</span>;
00809                 <span class="keywordflow">case</span> -DWC_E_RESTART:
00810                         req-&gt;status = -ECONNRESET;
00811                         <span class="keywordflow">break</span>;
00812                 <span class="keywordflow">case</span> -DWC_E_INVALID:
00813                         req-&gt;status = -EINVAL;
00814                         <span class="keywordflow">break</span>;
00815                 <span class="keywordflow">case</span> -DWC_E_TIMEOUT:
00816                         req-&gt;status = -ETIMEDOUT;
00817                         <span class="keywordflow">break</span>;
00818                 <span class="keywordflow">default</span>:
00819                         req-&gt;status = status;
00820 
00821                 }
00822 
00823                 req-&gt;actual = actual;
00824                 DWC_SPINUNLOCK(pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o20">lock</a>);
00825                 req-&gt;complete(ep_handle, req);
00826                 DWC_SPINLOCK(pcd-&gt;<a class="code" href="structdwc__otg__pcd.html#o20">lock</a>);
00827         }
00828 <span class="preprocessor">#ifdef PCI_INTERFACE</span>
00829 <span class="preprocessor"></span>        dev = gadget_wrapper-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>-&gt;<a class="code" href="structdwc__otg__pcd.html#o1">otg_dev</a>-&gt;<a class="code" href="structdwc__otg__device.html#o0">os_dep</a>.pcidev;
00830         ep = <a class="code" href="dwc__otg__pcd__linux_8c.html#a5">ep_from_handle</a>(pcd, ep_handle);
00831         <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__pcd_8h.html#a3">GET_CORE_IF</a>(pcd)-&gt;dma_enable) {
00832                 <span class="keywordflow">if</span> (req-&gt;length != 0)
00833                         pci_unmap_single(dev, req-&gt;dma, req-&gt;length,
00834                                          ep-&gt;<a class="code" href="structdwc__otg__pcd__ep.html#o7">dwc_ep</a>.
00835                                          is_in ? PCI_DMA_TODEVICE :
00836                                          PCI_DMA_FROMDEVICE);
00837         }
00838 <span class="preprocessor">#endif</span>
00839 <span class="preprocessor"></span>
00840         <span class="keywordflow">return</span> 0;
00841 }
00842 
00843 <span class="keyword">static</span> <span class="keywordtype">int</span> _connect(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, <span class="keywordtype">int</span> speed)
00844 {
00845         gadget_wrapper-&gt;gadget.speed = speed;
00846         <span class="keywordflow">return</span> 0;
00847 }
00848 
00849 <span class="keyword">static</span> <span class="keywordtype">int</span> _disconnect(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd)
00850 {
00851         <span class="keywordflow">if</span> (gadget_wrapper-&gt;driver &amp;&amp; gadget_wrapper-&gt;driver-&gt;disconnect) {
00852                 gadget_wrapper-&gt;driver-&gt;disconnect(&amp;gadget_wrapper-&gt;gadget);
00853         }
00854         <span class="keywordflow">return</span> 0;
00855 }
00856 
00857 <span class="keyword">static</span> <span class="keywordtype">int</span> _resume(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd)
00858 {
00859         <span class="keywordflow">if</span> (gadget_wrapper-&gt;driver &amp;&amp; gadget_wrapper-&gt;driver-&gt;resume) {
00860                 gadget_wrapper-&gt;driver-&gt;resume(&amp;gadget_wrapper-&gt;gadget);
00861         }
00862 
00863         <span class="keywordflow">return</span> 0;
00864 }
00865 
00866 <span class="keyword">static</span> <span class="keywordtype">int</span> _suspend(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd)
00867 {
00868         <span class="keywordflow">if</span> (gadget_wrapper-&gt;driver &amp;&amp; gadget_wrapper-&gt;driver-&gt;suspend) {
00869                 gadget_wrapper-&gt;driver-&gt;suspend(&amp;gadget_wrapper-&gt;gadget);
00870         }
00871         <span class="keywordflow">return</span> 0;
00872 }
00873 
<a name="l00877"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a26">00877</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a26">_hnp_changed</a>(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd)
00878 {
00879 
00880         <span class="keywordflow">if</span> (!gadget_wrapper-&gt;gadget.is_otg)
00881                 <span class="keywordflow">return</span> 0;
00882 
00883         gadget_wrapper-&gt;gadget.b_hnp_enable = <a class="code" href="dwc__otg__pcd__if_8h.html#a38">get_b_hnp_enable</a>(pcd);
00884         gadget_wrapper-&gt;gadget.a_hnp_support = get_a_hnp_support(pcd);
00885         gadget_wrapper-&gt;gadget.a_alt_hnp_support = get_a_alt_hnp_support(pcd);
00886         <span class="keywordflow">return</span> 0;
00887 }
00888 
00889 <span class="keyword">static</span> <span class="keywordtype">int</span> _reset(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd)
00890 {
00891         <span class="keywordflow">return</span> 0;
00892 }
00893 
00894 <span class="preprocessor">#ifdef DWC_UTE_CFI</span>
00895 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> _cfi_setup(<a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> * pcd, <span class="keywordtype">void</span> *cfi_req)
00896 {
00897         <span class="keywordtype">int</span> retval = -DWC_E_INVALID;
00898         <span class="keywordflow">if</span> (gadget_wrapper-&gt;driver-&gt;cfi_feature_setup) {
00899                 retval =
00900                     gadget_wrapper-&gt;driver-&gt;
00901                     cfi_feature_setup(&amp;gadget_wrapper-&gt;gadget,
00902                                       (<span class="keyword">struct</span> <a class="code" href="structcfi__usb__ctrlrequest.html">cfi_usb_ctrlrequest</a> *)cfi_req);
00903         }
00904 
00905         <span class="keywordflow">return</span> retval;
00906 }
00907 <span class="preprocessor">#endif</span>
00908 <span class="preprocessor"></span>
00909 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structdwc__otg__pcd__function__ops.html">dwc_otg_pcd_function_ops</a> fops = {
00910         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o3">complete</a> = _complete,
00911 <span class="preprocessor">#ifdef DWC_EN_ISOC</span>
00912 <span class="preprocessor"></span>        .<a class="code" href="structdwc__otg__pcd__function__ops.html#o4">isoc_complete</a> = _isoc_complete,
00913 <span class="preprocessor">#endif</span>
00914 <span class="preprocessor"></span>        .<a class="code" href="structdwc__otg__pcd__function__ops.html#o2">setup</a> = _setup,
00915         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o1">disconnect</a> = _disconnect,
00916         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o0">connect</a> = _connect,
00917         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o7">resume</a> = _resume,
00918         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o5">suspend</a> = _suspend,
00919         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o9">hnp_changed</a> = _hnp_changed,
00920         .<a class="code" href="structdwc__otg__pcd__function__ops.html#o8">reset</a> = _reset,
00921 <span class="preprocessor">#ifdef DWC_UTE_CFI</span>
00922 <span class="preprocessor"></span>        .<a class="code" href="structdwc__otg__pcd__function__ops.html#o10">cfi_setup</a> = _cfi_setup,
00923 <span class="preprocessor">#endif</span>
00924 <span class="preprocessor"></span><span class="preprocessor">#ifdef DWC_UTE_PER_IO</span>
00925 <span class="preprocessor"></span>        .xisoc_complete = _xisoc_complete,
00926 <span class="preprocessor">#endif</span>
00927 <span class="preprocessor"></span>};
00928 
<a name="l00932"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a28">00932</a> <span class="keyword">static</span> irqreturn_t <a class="code" href="dwc__otg__pcd__linux_8c.html#a28">dwc_otg_pcd_irq</a>(<span class="keywordtype">int</span> irq, <span class="keywordtype">void</span> *dev)
00933 {
00934         <a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd = dev;
00935         int32_t retval = IRQ_NONE;
00936 
00937         retval = <a class="code" href="dwc__otg__pcd__intr_8c.html#a63">dwc_otg_pcd_handle_intr</a>(pcd);
00938         <span class="keywordflow">if</span> (retval != 0) {
00939                 S3C2410X_CLEAR_EINTPEND();
00940         }
00941         <span class="keywordflow">return</span> IRQ_RETVAL(retval);
00942 }
00943 
<a name="l00950"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a29">00950</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a29">gadget_add_eps</a>(<span class="keyword">struct</span> gadget_wrapper *d)
00951 {
00952         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *names[] = {
00953 
00954                 <span class="stringliteral">"ep0"</span>,
00955                 <span class="stringliteral">"ep1in"</span>,
00956                 <span class="stringliteral">"ep2in"</span>,
00957                 <span class="stringliteral">"ep3in"</span>,
00958                 <span class="stringliteral">"ep4in"</span>,
00959                 <span class="stringliteral">"ep5in"</span>,
00960                 <span class="stringliteral">"ep6in"</span>,
00961                 <span class="stringliteral">"ep7in"</span>,
00962                 <span class="stringliteral">"ep8in"</span>,
00963                 <span class="stringliteral">"ep9in"</span>,
00964                 <span class="stringliteral">"ep10in"</span>,
00965                 <span class="stringliteral">"ep11in"</span>,
00966                 <span class="stringliteral">"ep12in"</span>,
00967                 <span class="stringliteral">"ep13in"</span>,
00968                 <span class="stringliteral">"ep14in"</span>,
00969                 <span class="stringliteral">"ep15in"</span>,
00970                 <span class="stringliteral">"ep1out"</span>,
00971                 <span class="stringliteral">"ep2out"</span>,
00972                 <span class="stringliteral">"ep3out"</span>,
00973                 <span class="stringliteral">"ep4out"</span>,
00974                 <span class="stringliteral">"ep5out"</span>,
00975                 <span class="stringliteral">"ep6out"</span>,
00976                 <span class="stringliteral">"ep7out"</span>,
00977                 <span class="stringliteral">"ep8out"</span>,
00978                 <span class="stringliteral">"ep9out"</span>,
00979                 <span class="stringliteral">"ep10out"</span>,
00980                 <span class="stringliteral">"ep11out"</span>,
00981                 <span class="stringliteral">"ep12out"</span>,
00982                 <span class="stringliteral">"ep13out"</span>,
00983                 <span class="stringliteral">"ep14out"</span>,
00984                 <span class="stringliteral">"ep15out"</span>
00985         };
00986 
00987         <span class="keywordtype">int</span> i;
00988         <span class="keyword">struct </span>usb_ep *ep;
00989         int8_t dev_endpoints;
00990 
00991         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s\n"</span>, __func__);
00992 
00993         INIT_LIST_HEAD(&amp;d-&gt;gadget.ep_list);
00994         d-&gt;gadget.ep0 = &amp;d-&gt;ep0;
00995         d-&gt;gadget.speed = USB_SPEED_UNKNOWN;
00996 
00997         INIT_LIST_HEAD(&amp;d-&gt;gadget.ep0-&gt;ep_list);
00998 
01002         ep = &amp;d-&gt;ep0;
01003 
01004         <span class="comment">/* Init the usb_ep structure. */</span>
01005         ep-&gt;name = names[0];
01006         ep-&gt;ops = (<span class="keyword">struct </span>usb_ep_ops *)&amp;dwc_otg_pcd_ep_ops;
01007 
01012         ep-&gt;maxpacket = MAX_PACKET_SIZE;
01013         <a class="code" href="dwc__otg__pcd__if_8h.html#a19">dwc_otg_pcd_ep_enable</a>(d-&gt;pcd, NULL, ep);
01014 
01015         list_add_tail(&amp;ep-&gt;ep_list, &amp;d-&gt;gadget.ep_list);
01016 
01020         dev_endpoints = d-&gt;pcd-&gt;core_if-&gt;dev_if-&gt;num_in_eps;
01021 
01022         <span class="keywordflow">for</span> (i = 0; i &lt; dev_endpoints; i++) {
01023                 ep = &amp;d-&gt;in_ep[i];
01024 
01025                 <span class="comment">/* Init the usb_ep structure. */</span>
01026                 ep-&gt;name = names[d-&gt;pcd-&gt;in_ep[i].dwc_ep.num];
01027                 ep-&gt;ops = (<span class="keyword">struct </span>usb_ep_ops *)&amp;dwc_otg_pcd_ep_ops;
01028 
01033                 ep-&gt;maxpacket = MAX_PACKET_SIZE;
01034                 list_add_tail(&amp;ep-&gt;ep_list, &amp;d-&gt;gadget.ep_list);
01035         }
01036 
01037         dev_endpoints = d-&gt;pcd-&gt;core_if-&gt;dev_if-&gt;num_out_eps;
01038 
01039         <span class="keywordflow">for</span> (i = 0; i &lt; dev_endpoints; i++) {
01040                 ep = &amp;d-&gt;out_ep[i];
01041 
01042                 <span class="comment">/* Init the usb_ep structure. */</span>
01043                 ep-&gt;name = names[15 + d-&gt;pcd-&gt;out_ep[i].dwc_ep.num];
01044                 ep-&gt;ops = (<span class="keyword">struct </span>usb_ep_ops *)&amp;dwc_otg_pcd_ep_ops;
01045 
01050                 ep-&gt;maxpacket = MAX_PACKET_SIZE;
01051 
01052                 list_add_tail(&amp;ep-&gt;ep_list, &amp;d-&gt;gadget.ep_list);
01053         }
01054 
01055         <span class="comment">/* remove ep0 from the list.  There is a ep0 pointer. */</span>
01056         list_del_init(&amp;d-&gt;ep0.ep_list);
01057 
01058         d-&gt;ep0.maxpacket = MAX_EP0_SIZE;
01059 }
01060 
<a name="l01067"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a30">01067</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a30">dwc_otg_pcd_gadget_release</a>(<span class="keyword">struct</span> device *dev)
01068 {
01069         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p)\n"</span>, __func__, dev);
01070 }
01071 
01072 <span class="keyword">static</span> <span class="keyword">struct </span>gadget_wrapper *alloc_wrapper(
01073 #ifdef LM_INTERFACE
01074         <span class="keyword">struct</span> lm_device *_dev
01075 #elif  defined(PCI_INTERFACE)
01076         <span class="keyword">struct</span> pci_dev *_dev
01077 #endif
01078     )
01079 {
01080         <span class="keyword">static</span> <span class="keywordtype">char</span> pcd_name[] = <span class="stringliteral">"dwc_otg_pcd"</span>;
01081 <span class="preprocessor">#ifdef LM_INTERFACE</span>
01082 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = lm_get_drvdata(_dev);
01083 <span class="preprocessor">#elif defined(PCI_INTERFACE)</span>
01084 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = pci_get_drvdata(_dev);
01085 <span class="preprocessor">#endif</span>
01086 <span class="preprocessor"></span>
01087         <span class="keyword">struct </span>gadget_wrapper *d;
01088         <span class="keywordtype">int</span> retval;
01089 
01090         d = DWC_ALLOC(<span class="keyword">sizeof</span>(*d));
01091         <span class="keywordflow">if</span> (d == NULL) {
01092                 <span class="keywordflow">return</span> NULL;
01093         }
01094 
01095         memset(d, 0, <span class="keyword">sizeof</span>(*d));
01096 
01097         d-&gt;gadget.name = pcd_name;
01098         d-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a> = otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>;
01099 
01100 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,30)</span>
01101 <span class="preprocessor"></span>        strcpy(d-&gt;gadget.dev.bus_id, <span class="stringliteral">"gadget"</span>);
01102 <span class="preprocessor">#else</span>
01103 <span class="preprocessor"></span>        dev_set_name(&amp;d-&gt;gadget.dev, <span class="stringliteral">"%s"</span>, <span class="stringliteral">"gadget"</span>);
01104 <span class="preprocessor">#endif</span>
01105 <span class="preprocessor"></span>
01106         d-&gt;gadget.dev.parent = &amp;_dev-&gt;dev;
01107         d-&gt;gadget.dev.release = dwc_otg_pcd_gadget_release;
01108         d-&gt;gadget.ops = &amp;dwc_otg_pcd_ops;
01109         d-&gt;gadget.is_dualspeed = <a class="code" href="dwc__otg__pcd__if_8h.html#a36">dwc_otg_pcd_is_dualspeed</a>(otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>);
01110         d-&gt;gadget.is_otg = <a class="code" href="dwc__otg__pcd__if_8h.html#a37">dwc_otg_pcd_is_otg</a>(otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>);
01111 
01112         d-&gt;driver = 0;
01113         <span class="comment">/* Register the gadget device */</span>
01114         retval = device_register(&amp;d-&gt;gadget.dev);
01115         <span class="keywordflow">if</span> (retval != 0) {
01116                 DWC_ERROR(<span class="stringliteral">"device_register failed\n"</span>);
01117                 DWC_FREE(d);
01118                 <span class="keywordflow">return</span> NULL;
01119         }
01120 
01121         <span class="keywordflow">return</span> d;
01122 }
01123 
01124 <span class="keyword">static</span> <span class="keywordtype">void</span> free_wrapper(<span class="keyword">struct</span> gadget_wrapper *d)
01125 {
01126         <span class="keywordflow">if</span> (d-&gt;driver) {
01127                 <span class="comment">/* should have been done already by driver model core */</span>
01128                 DWC_WARN(<span class="stringliteral">"driver '%s' is still registered\n"</span>,
01129                          d-&gt;driver-&gt;driver.name);
01130                 <a class="code" href="dwc__otg__pcd__linux_8c.html#a37">usb_gadget_unregister_driver</a>(d-&gt;driver);
01131         }
01132 
01133         device_unregister(&amp;d-&gt;gadget.dev);
01134         DWC_FREE(d);
01135 }
01136 
<a name="l01141"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a33">01141</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__driver_8c.html#a5">pcd_init</a>(
01142 #ifdef LM_INTERFACE
01143         <span class="keyword">struct</span> lm_device *_dev
01144 #elif  defined(PCI_INTERFACE)
01145         <span class="keyword">struct</span> pci_dev *_dev
01146 #endif
01147     )
01148 {
01149 <span class="preprocessor">#ifdef LM_INTERFACE</span>
01150 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = lm_get_drvdata(_dev);
01151 <span class="preprocessor">#elif  defined(PCI_INTERFACE)</span>
01152 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = pci_get_drvdata(_dev);
01153 <span class="preprocessor">#endif</span>
01154 <span class="preprocessor"></span>
01155         <span class="keywordtype">int</span> retval = 0;
01156 
01157         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p)\n"</span>, __func__, _dev);
01158 
01159         otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a> = <a class="code" href="dwc__otg__pcd__if_8h.html#a16">dwc_otg_pcd_init</a>(otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o1">core_if</a>);
01160 
01161         <span class="keywordflow">if</span> (!otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>) {
01162                 DWC_ERROR(<span class="stringliteral">"dwc_otg_pcd_init failed\n"</span>);
01163                 <span class="keywordflow">return</span> -ENOMEM;
01164         }
01165 
01166         otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>-&gt;<a class="code" href="structdwc__otg__pcd.html#o1">otg_dev</a> = otg_dev;
01167         gadget_wrapper = alloc_wrapper(_dev);
01168 
01169         <span class="comment">/*</span>
01170 <span class="comment">         * Initialize EP structures</span>
01171 <span class="comment">         */</span>
01172         <a class="code" href="dwc__otg__pcd__linux_8c.html#a29">gadget_add_eps</a>(gadget_wrapper);
01173         <span class="comment">/*</span>
01174 <span class="comment">         * Setup interupt handler</span>
01175 <span class="comment">         */</span>
01176         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"registering handler for irq%d\n"</span>, _dev-&gt;irq);
01177         retval = request_irq(_dev-&gt;irq, <a class="code" href="dwc__otg__pcd__linux_8c.html#a28">dwc_otg_pcd_irq</a>,
01178                              IRQF_SHARED | IRQF_DISABLED,
01179                              gadget_wrapper-&gt;gadget.name, otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>);
01180         <span class="keywordflow">if</span> (retval != 0) {
01181                 DWC_ERROR(<span class="stringliteral">"request of irq%d failed\n"</span>, _dev-&gt;irq);
01182                 free_wrapper(gadget_wrapper);
01183                 <span class="keywordflow">return</span> -EBUSY;
01184         }
01185 
01186         <a class="code" href="dwc__otg__pcd__if_8h.html#a18">dwc_otg_pcd_start</a>(gadget_wrapper-&gt;pcd, &amp;fops);
01187 
01188         <span class="keywordflow">return</span> retval;
01189 }
01190 
<a name="l01194"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a34">01194</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__driver_8c.html#a7">pcd_remove</a>(
01195 #ifdef LM_INTERFACE
01196         <span class="keyword">struct</span> lm_device *_dev
01197 #elif  defined(PCI_INTERFACE)
01198         <span class="keyword">struct</span> pci_dev *_dev
01199 #endif
01200     )
01201 {
01202 <span class="preprocessor">#ifdef LM_INTERFACE</span>
01203 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = lm_get_drvdata(_dev);
01204 <span class="preprocessor">#elif  defined(PCI_INTERFACE)</span>
01205 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = pci_get_drvdata(_dev);
01206 <span class="preprocessor">#endif</span>
01207 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__pcd.html">dwc_otg_pcd_t</a> *pcd = otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>;
01208 
01209         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"%s(%p)\n"</span>, __func__, _dev);
01210 
01211         <span class="comment">/*</span>
01212 <span class="comment">         * Free the IRQ</span>
01213 <span class="comment">         */</span>
01214         free_irq(_dev-&gt;irq, pcd);
01215         <a class="code" href="dwc__otg__pcd__if_8h.html#a17">dwc_otg_pcd_remove</a>(otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a>);
01216         free_wrapper(gadget_wrapper);
01217         otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o2">pcd</a> = 0;
01218 }
01219 
01231 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,37)</span>
01232 <span class="preprocessor"></span><span class="keywordtype">int</span> usb_gadget_register_driver(<span class="keyword">struct</span> usb_gadget_driver *driver)
01233 #<span class="keywordflow">else</span>
<a name="l01234"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a35">01234</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a35">usb_gadget_probe_driver</a>(<span class="keyword">struct</span> usb_gadget_driver *driver,
01235                 <span class="keywordtype">int</span> (*bind)(<span class="keyword">struct</span> usb_gadget *))
01236 #endif
01237 {
01238         <span class="keywordtype">int</span> retval;
01239 
01240         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a2">DBG_PCD</a>, <span class="stringliteral">"registering gadget driver '%s'\n"</span>,
01241                     driver-&gt;driver.name);
01242 
01243         <span class="keywordflow">if</span> (!driver || driver-&gt;speed == USB_SPEED_UNKNOWN ||
01244 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,37)</span>
01245 <span class="preprocessor"></span>            !driver-&gt;bind ||
01246 <span class="preprocessor">#else</span>
01247 <span class="preprocessor"></span>                !bind ||
01248 <span class="preprocessor">#endif</span>
01249 <span class="preprocessor"></span>            !driver-&gt;unbind || !driver-&gt;disconnect || !driver-&gt;setup) {
01250                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"EINVAL\n"</span>);
01251                 <span class="keywordflow">return</span> -EINVAL;
01252         }
01253         <span class="keywordflow">if</span> (gadget_wrapper == 0) {
01254                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"ENODEV\n"</span>);
01255                 <span class="keywordflow">return</span> -ENODEV;
01256         }
01257         <span class="keywordflow">if</span> (gadget_wrapper-&gt;driver != 0) {
01258                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a3">DBG_PCDV</a>, <span class="stringliteral">"EBUSY (%p)\n"</span>, gadget_wrapper-&gt;driver);
01259                 <span class="keywordflow">return</span> -EBUSY;
01260         }
01261 
01262         <span class="comment">/* hook up the driver */</span>
01263         gadget_wrapper-&gt;driver = driver;
01264         gadget_wrapper-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
01265 
01266         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a2">DBG_PCD</a>, <span class="stringliteral">"bind to driver %s\n"</span>, driver-&gt;driver.name);
01267 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,37)</span>
01268 <span class="preprocessor"></span>        retval = driver-&gt;bind(&amp;gadget_wrapper-&gt;gadget);
01269 <span class="preprocessor">#else</span>
01270 <span class="preprocessor"></span>        retval = bind(&amp;gadget_wrapper-&gt;gadget);
01271 <span class="preprocessor">#endif</span>
01272 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (retval) {
01273                 DWC_ERROR(<span class="stringliteral">"bind to driver %s --&gt; error %d\n"</span>,
01274                           driver-&gt;driver.name, retval);
01275                 gadget_wrapper-&gt;driver = 0;
01276                 gadget_wrapper-&gt;gadget.dev.driver = 0;
01277                 <span class="keywordflow">return</span> retval;
01278         }
01279         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"registered gadget driver '%s'\n"</span>,
01280                     driver-&gt;driver.name);
01281         <span class="keywordflow">return</span> 0;
01282 }
01283 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,37)</span>
01284 <span class="preprocessor"></span>EXPORT_SYMBOL(usb_gadget_register_driver);
01285 <span class="preprocessor">#else</span>
01286 <span class="preprocessor"></span>EXPORT_SYMBOL(usb_gadget_probe_driver);
01287 <span class="preprocessor">#endif</span>
01288 <span class="preprocessor"></span>
<a name="l01294"></a><a class="code" href="dwc__otg__pcd__linux_8c.html#a37">01294</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a37">usb_gadget_unregister_driver</a>(<span class="keyword">struct</span> usb_gadget_driver *driver)
01295 {
01296         <span class="comment">//DWC_DEBUGPL(DBG_PCDV,"%s(%p)\n", __func__, _driver);</span>
01297 
01298         <span class="keywordflow">if</span> (gadget_wrapper == 0) {
01299                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"%s Return(%d): s_pcd==0\n"</span>, __func__,
01300                             -ENODEV);
01301                 <span class="keywordflow">return</span> -ENODEV;
01302         }
01303         <span class="keywordflow">if</span> (driver == 0 || driver != gadget_wrapper-&gt;driver) {
01304                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"%s Return(%d): driver?\n"</span>, __func__,
01305                             -EINVAL);
01306                 <span class="keywordflow">return</span> -EINVAL;
01307         }
01308 
01309         driver-&gt;unbind(&amp;gadget_wrapper-&gt;gadget);
01310         gadget_wrapper-&gt;driver = 0;
01311 
01312         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"unregistered driver '%s'\n"</span>, driver-&gt;driver.name);
01313         <span class="keywordflow">return</span> 0;
01314 }
01315 
01316 EXPORT_SYMBOL(usb_gadget_unregister_driver);
01317 
01318 <span class="preprocessor">#endif </span><span class="comment">/* DWC_HOST_ONLY */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 27 03:56:38 2011 for DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>

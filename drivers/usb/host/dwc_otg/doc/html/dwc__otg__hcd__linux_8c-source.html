<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver: dwc_otg_hcd_linux.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>dwc_otg_hcd_linux.c</h1><a href="dwc__otg__hcd__linux_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/* ==========================================================================</span>
00002 <span class="comment"> * $File: //dwh/usb_iip/dev/software/otg/linux/drivers/dwc_otg_hcd_linux.c $</span>
00003 <span class="comment"> * $Revision: #20 $</span>
00004 <span class="comment"> * $Date: 2011/10/26 $</span>
00005 <span class="comment"> * $Change: 1872981 $</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,</span>
00008 <span class="comment"> * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless</span>
00009 <span class="comment"> * otherwise expressly agreed to in writing between Synopsys and you.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * The Software IS NOT an item of Licensed Software or Licensed Product under</span>
00012 <span class="comment"> * any End User Software License Agreement or Agreement for Licensed Product</span>
00013 <span class="comment"> * with Synopsys or any supplement thereto. You are permitted to use and</span>
00014 <span class="comment"> * redistribute this Software in source and binary forms, with or without</span>
00015 <span class="comment"> * modification, provided that redistributions of source code must retain this</span>
00016 <span class="comment"> * notice. You may not view, use, disclose, copy or distribute this file or</span>
00017 <span class="comment"> * any information contained herein except pursuant to this license grant from</span>
00018 <span class="comment"> * Synopsys. If you do not agree with this notice, including the disclaimer</span>
00019 <span class="comment"> * below, then you are not authorized to use the Software.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS</span>
00022 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00023 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
00024 <span class="comment"> * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,</span>
00025 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
00026 <span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
00027 <span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
00028 <span class="comment"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
00029 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
00030 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
00031 <span class="comment"> * DAMAGE.</span>
00032 <span class="comment"> * ========================================================================== */</span>
00033 <span class="preprocessor">#ifndef DWC_DEVICE_ONLY</span>
00034 <span class="preprocessor"></span>
00041 <span class="preprocessor">#include &lt;linux/kernel.h&gt;</span>
00042 <span class="preprocessor">#include &lt;linux/module.h&gt;</span>
00043 <span class="preprocessor">#include &lt;linux/moduleparam.h&gt;</span>
00044 <span class="preprocessor">#include &lt;linux/init.h&gt;</span>
00045 <span class="preprocessor">#include &lt;linux/device.h&gt;</span>
00046 <span class="preprocessor">#include &lt;linux/errno.h&gt;</span>
00047 <span class="preprocessor">#include &lt;linux/list.h&gt;</span>
00048 <span class="preprocessor">#include &lt;linux/interrupt.h&gt;</span>
00049 <span class="preprocessor">#include &lt;linux/string.h&gt;</span>
00050 <span class="preprocessor">#include &lt;linux/dma-mapping.h&gt;</span>
00051 <span class="preprocessor">#include &lt;linux/version.h&gt;</span>
00052 <span class="preprocessor">#include &lt;asm/io.h&gt;</span>
00053 <span class="preprocessor">#include &lt;linux/usb.h&gt;</span>
00054 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,35)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#include &lt;../drivers/usb/core/hcd.h&gt;</span>
00056 <span class="preprocessor">#else</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#include &lt;linux/usb/hcd.h&gt;</span>
00058 <span class="preprocessor">#endif</span>
00059 <span class="preprocessor"></span>
00060 <span class="preprocessor">#include "<a class="code" href="dwc__otg__hcd__if_8h.html">dwc_otg_hcd_if.h</a>"</span>
00061 <span class="preprocessor">#include "<a class="code" href="dwc__otg__dbg_8h.html">dwc_otg_dbg.h</a>"</span>
00062 <span class="preprocessor">#include "<a class="code" href="dwc__otg__driver_8h.html">dwc_otg_driver.h</a>"</span>
00063 <span class="preprocessor">#include "<a class="code" href="dwc__otg__hcd_8h.html">dwc_otg_hcd.h</a>"</span>
<a name="l00068"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a0">00068</a> <span class="preprocessor">#define dwc_ep_addr_to_endpoint(_bEndpointAddress_) ((_bEndpointAddress_ &amp; USB_ENDPOINT_NUMBER_MASK) | \</span>
00069 <span class="preprocessor">                                                     ((_bEndpointAddress_ &amp; USB_DIR_IN) != 0) &lt;&lt; 4)</span>
00070 <span class="preprocessor"></span>
00071 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> dwc_otg_hcd_name[] = <span class="stringliteral">"dwc_otg_hcd"</span>;
00072 
00075 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a4">urb_enqueue</a>(<span class="keyword">struct</span> usb_hcd *hcd,
00076 #<span class="keywordflow">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)
00077                        <span class="keyword">struct</span> usb_host_endpoint *ep,
00078 #endif
00079                        <span class="keyword">struct</span> urb *urb, gfp_t mem_flags);
00080 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00081 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a5">urb_dequeue</a>(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> urb *urb);
00082 <span class="preprocessor">#else</span>
00083 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a5">urb_dequeue</a>(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> urb *urb, <span class="keywordtype">int</span> status);
00084 <span class="preprocessor">#endif</span>
00085 <span class="preprocessor"></span>
00086 <span class="keyword">static</span> <span class="keywordtype">void</span> endpoint_disable(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> usb_host_endpoint *ep);
00087 <span class="preprocessor">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30)</span>
00088 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> endpoint_reset(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> usb_host_endpoint *ep);
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span><span class="keyword">static</span> irqreturn_t <a class="code" href="dwc__otg__hcd__linux_8c.html#a8">dwc_otg_hcd_irq</a>(<span class="keyword">struct</span> usb_hcd *hcd);
00091 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a9">hcd_start</a>(<span class="keyword">struct</span> usb_hcd *hcd);
00092 <span class="keyword">extern</span> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a10">hcd_stop</a>(<span class="keyword">struct</span> usb_hcd *hcd);
00093 <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a17">get_frame_number</a>(<span class="keyword">struct</span> usb_hcd *hcd);
00094 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a12">hub_status_data</a>(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keywordtype">char</span> *buf);
00095 <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a13">hub_control</a>(<span class="keyword">struct</span> usb_hcd *hcd,
00096                        u16 typeReq,
00097                        u16 wValue, u16 wIndex, <span class="keywordtype">char</span> *buf, u16 wLength);
00098 
00099 <span class="keyword">struct </span>wrapper_priv_data {
00100         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>;
00101 };
00102 
00105 <span class="keyword">static</span> <span class="keyword">struct </span>hc_driver dwc_otg_hc_driver = {
00106 
00107         .description = dwc_otg_hcd_name,
00108         .product_desc = <span class="stringliteral">"DWC OTG Controller"</span>,
00109         .hcd_priv_size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>wrapper_priv_data),
00110 
00111         .irq = dwc_otg_hcd_irq,
00112 
00113         .flags = HCD_MEMORY | HCD_USB2,
00114 
00115         <span class="comment">//.reset =              </span>
00116         .start = hcd_start,
00117         <span class="comment">//.suspend =            </span>
00118         <span class="comment">//.resume =             </span>
00119         .stop = hcd_stop,
00120 
00121         .urb_enqueue = urb_enqueue,
00122         .urb_dequeue = urb_dequeue,
00123         .endpoint_disable = endpoint_disable,
00124 <span class="preprocessor">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30)</span>
00125 <span class="preprocessor"></span>        .endpoint_reset = endpoint_reset,
00126 <span class="preprocessor">#endif</span>
00127 <span class="preprocessor"></span>        .get_frame_number = get_frame_number,
00128 
00129         .hub_status_data = hub_status_data,
00130         .hub_control = hub_control,
00131         <span class="comment">//.bus_suspend =                </span>
00132         <span class="comment">//.bus_resume =         </span>
00133 };
00134 
<a name="l00136"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a14">00136</a> <span class="keyword">static</span> <span class="keyword">inline</span> <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(<span class="keyword">struct</span> usb_hcd *hcd)
00137 {
00138         <span class="keyword">struct </span>wrapper_priv_data *p;
00139         p = (<span class="keyword">struct </span>wrapper_priv_data *)(hcd-&gt;hcd_priv);
00140         <span class="keywordflow">return</span> p-&gt;dwc_otg_hcd;
00141 }
00142 
<a name="l00144"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a15">00144</a> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct </span>usb_hcd *<a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>)
00145 {
00146         <span class="keywordflow">return</span> <a class="code" href="dwc__otg__hcd__if_8h.html#a14">dwc_otg_hcd_get_priv_data</a>(dwc_otg_hcd);
00147 }
00148 
<a name="l00150"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a16">00150</a> <span class="keyword">inline</span> <span class="keyword">struct </span>usb_host_endpoint *<a class="code" href="dwc__otg__hcd__linux_8c.html#a16">dwc_urb_to_endpoint</a>(<span class="keyword">struct</span> urb *urb)
00151 {
00152         <span class="keyword">struct </span>usb_device *dev = urb-&gt;dev;
00153         <span class="keywordtype">int</span> ep_num = usb_pipeendpoint(urb-&gt;pipe);
00154 
00155         <span class="keywordflow">if</span> (usb_pipein(urb-&gt;pipe))
00156                 <span class="keywordflow">return</span> dev-&gt;ep_in[ep_num];
00157         <span class="keywordflow">else</span>
00158                 <span class="keywordflow">return</span> dev-&gt;ep_out[ep_num];
00159 }
00160 
00161 <span class="keyword">static</span> <span class="keywordtype">int</span> _disconnect(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00162 {
00163         <span class="keyword">struct </span>usb_hcd *usb_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(hcd);
00164 
00165         usb_hcd-&gt;self.is_b_host = 0;
00166         <span class="keywordflow">return</span> 0;
00167 }
00168 
00169 <span class="keyword">static</span> <span class="keywordtype">int</span> _start(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00170 {
00171         <span class="keyword">struct </span>usb_hcd *usb_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(hcd);
00172 
00173         usb_hcd-&gt;self.is_b_host = <a class="code" href="dwc__otg__hcd__if_8h.html#a21">dwc_otg_hcd_is_b_host</a>(hcd);
00174         <a class="code" href="dwc__otg__hcd__linux_8c.html#a9">hcd_start</a>(usb_hcd);
00175 
00176         <span class="keywordflow">return</span> 0;
00177 }
00178 
00179 <span class="keyword">static</span> <span class="keywordtype">int</span> _hub_info(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <span class="keywordtype">void</span> *urb_handle, uint32_t * hub_addr,
00180                      uint32_t * port_addr)
00181 {
00182         <span class="keyword">struct </span>urb *urb = (<span class="keyword">struct </span>urb *)urb_handle;
00183         <span class="keywordflow">if</span> (urb-&gt;dev-&gt;tt) {
00184                 *hub_addr = urb-&gt;dev-&gt;tt-&gt;hub-&gt;devnum;
00185         } <span class="keywordflow">else</span> {
00186                 *hub_addr = 0;
00187         }
00188         *port_addr = urb-&gt;dev-&gt;ttport;
00189         <span class="keywordflow">return</span> 0;
00190 }
00191 
00192 <span class="keyword">static</span> <span class="keywordtype">int</span> _speed(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <span class="keywordtype">void</span> *urb_handle)
00193 {
00194         <span class="keyword">struct </span>urb *urb = (<span class="keyword">struct </span>urb *)urb_handle;
00195         <span class="keywordflow">return</span> urb-&gt;dev-&gt;speed;
00196 }
00197 
00198 <span class="keyword">static</span> <span class="keywordtype">int</span> _get_b_hnp_enable(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00199 {
00200         <span class="keyword">struct </span>usb_hcd *usb_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(hcd);
00201         <span class="keywordflow">return</span> usb_hcd-&gt;self.b_hnp_enable;
00202 }
00203 
00204 <span class="keyword">static</span> <span class="keywordtype">void</span> allocate_bus_bandwidth(<span class="keyword">struct</span> usb_hcd *hcd, uint32_t bw,
00205                                    <span class="keyword">struct</span> urb *urb)
00206 {
00207         hcd_to_bus(hcd)-&gt;bandwidth_allocated += bw / urb-&gt;interval;
00208         <span class="keywordflow">if</span> (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
00209                 hcd_to_bus(hcd)-&gt;bandwidth_isoc_reqs++;
00210         } <span class="keywordflow">else</span> {
00211                 hcd_to_bus(hcd)-&gt;bandwidth_int_reqs++;
00212         }
00213 }
00214 
00215 <span class="keyword">static</span> <span class="keywordtype">void</span> free_bus_bandwidth(<span class="keyword">struct</span> usb_hcd *hcd, uint32_t bw,
00216                                <span class="keyword">struct</span> urb *urb)
00217 {
00218         hcd_to_bus(hcd)-&gt;bandwidth_allocated -= bw / urb-&gt;interval;
00219         <span class="keywordflow">if</span> (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
00220                 hcd_to_bus(hcd)-&gt;bandwidth_isoc_reqs--;
00221         } <span class="keywordflow">else</span> {
00222                 hcd_to_bus(hcd)-&gt;bandwidth_int_reqs--;
00223         }
00224 }
00225 
<a name="l00230"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a24">00230</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a24">_complete</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <span class="keywordtype">void</span> *urb_handle,
00231                      dwc_otg_hcd_urb_t * dwc_otg_urb, int32_t status)
00232 {
00233         <span class="keyword">struct </span>urb *urb = (<span class="keyword">struct </span>urb *)urb_handle;
00234 <span class="preprocessor">#ifdef DEBUG</span>
00235 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CHK_DEBUG_LEVEL(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a> | <a class="code" href="dwc__otg__dbg_8h.html#a6">DBG_HCD_URB</a>)) {
00236                 DWC_PRINTF(<span class="stringliteral">"%s: urb %p, device %d, ep %d %s, status=%d\n"</span>,
00237                            __func__, urb, usb_pipedevice(urb-&gt;pipe),
00238                            usb_pipeendpoint(urb-&gt;pipe),
00239                            usb_pipein(urb-&gt;pipe) ? <span class="stringliteral">"IN"</span> : <span class="stringliteral">"OUT"</span>, status);
00240                 <span class="keywordflow">if</span> (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
00241                         <span class="keywordtype">int</span> i;
00242                         <span class="keywordflow">for</span> (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
00243                                 DWC_PRINTF(<span class="stringliteral">"  ISO Desc %d status: %d\n"</span>,
00244                                            i, urb-&gt;iso_frame_desc[i].status);
00245                         }
00246                 }
00247         }
00248 <span class="preprocessor">#endif</span>
00249 <span class="preprocessor"></span>
00250         urb-&gt;actual_length = <a class="code" href="dwc__otg__hcd__if_8h.html#a30">dwc_otg_hcd_urb_get_actual_length</a>(dwc_otg_urb);
00251         <span class="comment">/* Convert status value. */</span>
00252         <span class="keywordflow">switch</span> (status) {
00253         <span class="keywordflow">case</span> -DWC_E_PROTOCOL:
00254                 status = -EPROTO;
00255                 <span class="keywordflow">break</span>;
00256         <span class="keywordflow">case</span> -DWC_E_IN_PROGRESS:
00257                 status = -EINPROGRESS;
00258                 <span class="keywordflow">break</span>;
00259         <span class="keywordflow">case</span> -DWC_E_PIPE:
00260                 status = -EPIPE;
00261                 <span class="keywordflow">break</span>;
00262         <span class="keywordflow">case</span> -DWC_E_IO:
00263                 status = -EIO;
00264                 <span class="keywordflow">break</span>;
00265         <span class="keywordflow">case</span> -DWC_E_TIMEOUT:
00266                 status = -ETIMEDOUT;
00267                 <span class="keywordflow">break</span>;
00268         <span class="keywordflow">case</span> -DWC_E_OVERFLOW:
00269                 status = -EOVERFLOW;
00270                 <span class="keywordflow">break</span>;
00271         <span class="keywordflow">default</span>:
00272                 <span class="keywordflow">if</span> (status) {
00273                         DWC_PRINTF(<span class="stringliteral">"Uknown urb status %d\n"</span>, status);
00274 
00275                 }
00276         }
00277 
00278         <span class="keywordflow">if</span> (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
00279                 <span class="keywordtype">int</span> i;
00280 
00281                 urb-&gt;error_count = <a class="code" href="dwc__otg__hcd__if_8h.html#a31">dwc_otg_hcd_urb_get_error_count</a>(dwc_otg_urb);
00282                 <span class="keywordflow">for</span> (i = 0; i &lt; urb-&gt;number_of_packets; ++i) {
00283                         urb-&gt;iso_frame_desc[i].actual_length =
00284                             <a class="code" href="dwc__otg__hcd_8c.html#a48">dwc_otg_hcd_urb_get_iso_desc_actual_length</a>
00285                             (dwc_otg_urb, i);
00286                         urb-&gt;iso_frame_desc[i].status =
00287                             <a class="code" href="dwc__otg__hcd__if_8h.html#a33">dwc_otg_hcd_urb_get_iso_desc_status</a>(dwc_otg_urb, i);
00288                 }
00289         }
00290 
00291         urb-&gt;status = status;
00292         urb-&gt;hcpriv = NULL;
00293         <span class="keywordflow">if</span> (!status) {
00294                 <span class="keywordflow">if</span> ((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
00295                     (urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length)) {
00296                         urb-&gt;status = -EREMOTEIO;
00297                 }
00298         }
00299 
00300         <span class="keywordflow">if</span> ((usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) ||
00301             (usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT)) {
00302                 <span class="keyword">struct </span>usb_host_endpoint *ep = <a class="code" href="dwc__otg__hcd__linux_8c.html#a16">dwc_urb_to_endpoint</a>(urb);
00303                 <span class="keywordflow">if</span> (ep) {
00304                         free_bus_bandwidth(<a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(hcd),
00305                                            <a class="code" href="dwc__otg__hcd__if_8h.html#a42">dwc_otg_hcd_get_ep_bandwidth</a>(hcd,
00306                                                                         ep-&gt;hcpriv),
00307                                            urb);
00308                 }
00309         }
00310 
00311         DWC_FREE(dwc_otg_urb);
00312 
00313         DWC_SPINUNLOCK(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>);
00314 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00315 <span class="preprocessor"></span>        usb_hcd_giveback_urb(<a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(hcd), urb);
00316 <span class="preprocessor">#else</span>
00317 <span class="preprocessor"></span>        usb_hcd_giveback_urb(<a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(hcd), urb, status);
00318 <span class="preprocessor">#endif</span>
00319 <span class="preprocessor"></span>        DWC_SPINLOCK(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>);
00320 
00321         <span class="keywordflow">return</span> 0;
00322 }
00323 
00324 <span class="keyword">static</span> <span class="keyword">struct </span>dwc_otg_hcd_function_ops hcd_fops = {
00325         .start = _start,
00326         .disconnect = _disconnect,
00327         .hub_info = _hub_info,
00328         .speed = _speed,
00329         .complete = _complete,
00330         .get_b_hnp_enable = _get_b_hnp_enable,
00331 };
00332 
<a name="l00339"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a25">00339</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__driver_8c.html#a6">hcd_init</a>(
00340 #ifdef LM_INTERFACE
00341                     <span class="keyword">struct</span> lm_device *_dev
00342 #elif  defined(PCI_INTERFACE)
00343                     <span class="keyword">struct</span> pci_dev *_dev
00344 #endif
00345     )
00346 {
00347         <span class="keyword">struct </span>usb_hcd *hcd = NULL;
00348         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a> = NULL;
00349 <span class="preprocessor">#ifdef LM_INTERFACE</span>
00350 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = lm_get_drvdata(_dev);
00351 <span class="preprocessor">#elif  defined(PCI_INTERFACE)</span>
00352 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = pci_get_drvdata(_dev);
00353 <span class="preprocessor">#endif</span>
00354 <span class="preprocessor"></span>
00355         <span class="keywordtype">int</span> retval = 0;
00356 
00357         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"DWC OTG HCD INIT\n"</span>);
00358 
00359         <span class="comment">/* Set device flags indicating whether the HCD supports DMA. */</span>
00360         <span class="keywordflow">if</span> (dwc_otg_is_dma_enable(otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o1">core_if</a>)) {
00361 <span class="preprocessor">#ifdef LM_INTERFACE</span>
00362 <span class="preprocessor"></span>                _dev-&gt;dev.dma_mask = (<span class="keywordtype">void</span> *)~0;
00363                 _dev-&gt;dev.coherent_dma_mask = ~0;
00364 <span class="preprocessor">#elif  defined(PCI_INTERFACE)</span>
00365 <span class="preprocessor"></span>                pci_set_dma_mask(_dev, DMA_32BIT_MASK);
00366                 pci_set_consistent_dma_mask(_dev, DMA_32BIT_MASK);
00367 <span class="preprocessor">#endif</span>
00368 <span class="preprocessor"></span>
00369         } <span class="keywordflow">else</span> {
00370 <span class="preprocessor">#ifdef LM_INTERFACE</span>
00371 <span class="preprocessor"></span>                _dev-&gt;dev.dma_mask = (<span class="keywordtype">void</span> *)0;
00372                 _dev-&gt;dev.coherent_dma_mask = 0;
00373 <span class="preprocessor">#elif  defined(PCI_INTERFACE)</span>
00374 <span class="preprocessor"></span>                pci_set_dma_mask(_dev, 0);
00375                 pci_set_consistent_dma_mask(_dev, 0);
00376 <span class="preprocessor">#endif</span>
00377 <span class="preprocessor"></span>        }
00378 
00379         <span class="comment">/*</span>
00380 <span class="comment">         * Allocate memory for the base HCD plus the DWC OTG HCD.</span>
00381 <span class="comment">         * Initialize the base HCD.</span>
00382 <span class="comment">         */</span>
00383 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,30)</span>
00384 <span class="preprocessor"></span>        hcd = usb_create_hcd(&amp;dwc_otg_hc_driver, &amp;_dev-&gt;dev, _dev-&gt;dev.bus_id);
00385 <span class="preprocessor">#else</span>
00386 <span class="preprocessor"></span>        hcd = usb_create_hcd(&amp;dwc_otg_hc_driver, &amp;_dev-&gt;dev, dev_name(&amp;_dev-&gt;dev));
00387         hcd-&gt;has_tt = 1;
00388 <span class="comment">//      hcd-&gt;uses_new_polling = 1;</span>
00389 <span class="comment">//      hcd-&gt;poll_rh = 0;</span>
00390 <span class="preprocessor">#endif</span>
00391 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (!hcd) {
00392                 retval = -ENOMEM;
00393                 <span class="keywordflow">goto</span> error1;
00394         }
00395 
00396         hcd-&gt;regs = otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o0">os_dep</a>.base;
00397 
00398         <span class="comment">/* Initialize the DWC OTG HCD. */</span>
00399         dwc_otg_hcd = <a class="code" href="dwc__otg__hcd_8c.html#a1">dwc_otg_hcd_alloc_hcd</a>();
00400         <span class="keywordflow">if</span> (!dwc_otg_hcd) {
00401                 <span class="keywordflow">goto</span> error2;
00402         }
00403         ((<span class="keyword">struct </span>wrapper_priv_data *)(hcd-&gt;hcd_priv))-&gt;dwc_otg_hcd =
00404             dwc_otg_hcd;
00405         otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o3">hcd</a> = dwc_otg_hcd;
00406 
00407         <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__hcd__if_8h.html#a11">dwc_otg_hcd_init</a>(dwc_otg_hcd, otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o1">core_if</a>)) {
00408                 <span class="keywordflow">goto</span> error2;
00409         }
00410 
00411         otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o3">hcd</a>-&gt;<a class="code" href="structdwc__otg__hcd.html#o0">otg_dev</a> = otg_dev;
00412         hcd-&gt;self.otg_port = <a class="code" href="dwc__otg__hcd__if_8h.html#a19">dwc_otg_hcd_otg_port</a>(dwc_otg_hcd);
00413 <span class="preprocessor">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,33) //don't support for LM(with 2.6.20.1 kernel)</span>
00414 <span class="preprocessor"></span>        hcd-&gt;self.otg_version = <a class="code" href="dwc__otg__hcd__if_8h.html#a20">dwc_otg_get_otg_version</a>(otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o1">core_if</a>);
00415         <span class="comment">/* Don't support SG list at this point */</span>
00416         hcd-&gt;self.sg_tablesize = 0;
00417 <span class="preprocessor">#endif</span>
00418 <span class="preprocessor"></span>        <span class="comment">/*</span>
00419 <span class="comment">         * Finish generic HCD initialization and start the HCD. This function</span>
00420 <span class="comment">         * allocates the DMA buffer pool, registers the USB bus, requests the</span>
00421 <span class="comment">         * IRQ line, and calls hcd_start method.</span>
00422 <span class="comment">         */</span>
00423         retval = usb_add_hcd(hcd, _dev-&gt;irq, IRQF_SHARED | IRQF_DISABLED);
00424         <span class="keywordflow">if</span> (retval &lt; 0) {
00425                 <span class="keywordflow">goto</span> error2;
00426         }
00427 
00428         <a class="code" href="dwc__otg__hcd__if_8h.html#a15">dwc_otg_hcd_set_priv_data</a>(dwc_otg_hcd, hcd);
00429         <span class="keywordflow">return</span> 0;
00430 
00431 error2:
00432         usb_put_hcd(hcd);
00433 error1:
00434         <span class="keywordflow">return</span> retval;
00435 }
00436 
<a name="l00441"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a26">00441</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__driver_8c.html#a8">hcd_remove</a>(
00442 #ifdef LM_INTERFACE
00443                        <span class="keyword">struct</span> lm_device *_dev
00444 #elif  defined(PCI_INTERFACE)
00445                        <span class="keyword">struct</span> pci_dev *_dev
00446 #endif
00447     )
00448 {
00449 <span class="preprocessor">#ifdef LM_INTERFACE</span>
00450 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = lm_get_drvdata(_dev);
00451 <span class="preprocessor">#elif  defined(PCI_INTERFACE)</span>
00452 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__device.html">dwc_otg_device_t</a> *otg_dev = pci_get_drvdata(_dev);
00453 <span class="preprocessor">#endif</span>
00454 <span class="preprocessor"></span>
00455         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>;
00456         <span class="keyword">struct </span>usb_hcd *hcd;
00457 
00458         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"DWC OTG HCD REMOVE\n"</span>);
00459 
00460         <span class="keywordflow">if</span> (!otg_dev) {
00461                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"%s: otg_dev NULL!\n"</span>, __func__);
00462                 <span class="keywordflow">return</span>;
00463         }
00464 
00465         dwc_otg_hcd = otg_dev-&gt;<a class="code" href="structdwc__otg__device.html#o3">hcd</a>;
00466 
00467         <span class="keywordflow">if</span> (!dwc_otg_hcd) {
00468                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>, <span class="stringliteral">"%s: otg_dev-&gt;hcd NULL!\n"</span>, __func__);
00469                 <span class="keywordflow">return</span>;
00470         }
00471 
00472         hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a15">dwc_otg_hcd_to_hcd</a>(dwc_otg_hcd);
00473 
00474         <span class="keywordflow">if</span> (!hcd) {
00475                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a7">DBG_ANY</a>,
00476                             <span class="stringliteral">"%s: dwc_otg_hcd_to_hcd(dwc_otg_hcd) NULL!\n"</span>,
00477                             __func__);
00478                 <span class="keywordflow">return</span>;
00479         }
00480         usb_remove_hcd(hcd);
00481         <a class="code" href="dwc__otg__hcd__if_8h.html#a15">dwc_otg_hcd_set_priv_data</a>(dwc_otg_hcd, NULL);
00482         <a class="code" href="dwc__otg__hcd__if_8h.html#a12">dwc_otg_hcd_remove</a>(dwc_otg_hcd);
00483         usb_put_hcd(hcd);
00484 }
00485 
00486 <span class="comment">/* =========================================================================</span>
00487 <span class="comment"> *  Linux HC Driver Functions</span>
00488 <span class="comment"> * ========================================================================= */</span>
00489 
<a name="l00493"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a9">00493</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a9">hcd_start</a>(<span class="keyword">struct</span> usb_hcd *hcd)
00494 {
00495         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a> = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00496         <span class="keyword">struct </span>usb_bus *bus;
00497 
00498         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"DWC OTG HCD START\n"</span>);
00499         bus = hcd_to_bus(hcd);
00500 
00501         hcd-&gt;state = HC_STATE_RUNNING;
00502         <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__hcd__if_8h.html#a16">dwc_otg_hcd_start</a>(dwc_otg_hcd, &amp;hcd_fops)) {
00503                 <span class="keywordflow">return</span> 0;
00504         }
00505 
00506         <span class="comment">/* Initialize and connect root hub if one is not already attached */</span>
00507         <span class="keywordflow">if</span> (bus-&gt;root_hub) {
00508                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"DWC OTG HCD Has Root Hub\n"</span>);
00509                 <span class="comment">/* Inform the HUB driver to resume. */</span>
00510                 usb_hcd_resume_root_hub(hcd);
00511         }
00512 
00513         <span class="keywordflow">return</span> 0;
00514 }
00515 
<a name="l00520"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a10">00520</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a10">hcd_stop</a>(<span class="keyword">struct</span> usb_hcd *hcd)
00521 {
00522         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a> = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00523 
00524         <a class="code" href="dwc__otg__hcd__if_8h.html#a17">dwc_otg_hcd_stop</a>(dwc_otg_hcd);
00525 }
00526 
<a name="l00528"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a11">00528</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__pcd__linux_8c.html#a17">get_frame_number</a>(<span class="keyword">struct</span> usb_hcd *hcd)
00529 {
00530         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a> = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00531 
00532         <span class="keywordflow">return</span> <a class="code" href="dwc__otg__hcd__if_8h.html#a22">dwc_otg_hcd_get_frame_number</a>(dwc_otg_hcd);
00533 }
00534 
00535 <span class="preprocessor">#ifdef DEBUG</span>
00536 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> dump_urb_info(<span class="keyword">struct</span> urb *urb, <span class="keywordtype">char</span> *fn_name)
00537 {
00538         DWC_PRINTF(<span class="stringliteral">"%s, urb %p\n"</span>, fn_name, urb);
00539         DWC_PRINTF(<span class="stringliteral">"  Device address: %d\n"</span>, usb_pipedevice(urb-&gt;pipe));
00540         DWC_PRINTF(<span class="stringliteral">"  Endpoint: %d, %s\n"</span>, usb_pipeendpoint(urb-&gt;pipe),
00541                    (usb_pipein(urb-&gt;pipe) ? <span class="stringliteral">"IN"</span> : <span class="stringliteral">"OUT"</span>));
00542         DWC_PRINTF(<span class="stringliteral">"  Endpoint type: %s\n"</span>, ( {
00543                                              <span class="keywordtype">char</span> *pipetype;
00544                                              <span class="keywordflow">switch</span> (usb_pipetype(urb-&gt;pipe)) {
00545 <span class="keywordflow">case</span> PIPE_CONTROL:
00546 pipetype = <span class="stringliteral">"CONTROL"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">case</span> PIPE_BULK:
00547 pipetype = <span class="stringliteral">"BULK"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">case</span> PIPE_INTERRUPT:
00548 pipetype = <span class="stringliteral">"INTERRUPT"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">case</span> PIPE_ISOCHRONOUS:
00549 pipetype = <span class="stringliteral">"ISOCHRONOUS"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">default</span>:
00550                                              pipetype = <span class="stringliteral">"UNKNOWN"</span>; <span class="keywordflow">break</span>;};
00551                                              pipetype;}
00552                    )) ;
00553         DWC_PRINTF(<span class="stringliteral">"  Speed: %s\n"</span>, ( {
00554                                      <span class="keywordtype">char</span> *speed; <span class="keywordflow">switch</span> (urb-&gt;dev-&gt;speed) {
00555 <span class="keywordflow">case</span> USB_SPEED_HIGH:
00556 speed = <span class="stringliteral">"HIGH"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">case</span> USB_SPEED_FULL:
00557 speed = <span class="stringliteral">"FULL"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">case</span> USB_SPEED_LOW:
00558 speed = <span class="stringliteral">"LOW"</span>; <span class="keywordflow">break</span>; <span class="keywordflow">default</span>:
00559                                      speed = <span class="stringliteral">"UNKNOWN"</span>; <span class="keywordflow">break</span>;};
00560                                      speed;}
00561                    )) ;
00562         DWC_PRINTF(<span class="stringliteral">"  Max packet size: %d\n"</span>,
00563                    usb_maxpacket(urb-&gt;dev, urb-&gt;pipe, usb_pipeout(urb-&gt;pipe)));
00564         DWC_PRINTF(<span class="stringliteral">"  Data buffer length: %d\n"</span>, urb-&gt;transfer_buffer_length);
00565         DWC_PRINTF(<span class="stringliteral">"  Transfer buffer: %p, Transfer DMA: %p\n"</span>,
00566                    urb-&gt;transfer_buffer, (<span class="keywordtype">void</span> *)urb-&gt;transfer_dma);
00567         DWC_PRINTF(<span class="stringliteral">"  Setup buffer: %p, Setup DMA: %p\n"</span>,
00568                    urb-&gt;setup_packet, (<span class="keywordtype">void</span> *)urb-&gt;setup_dma);
00569         DWC_PRINTF(<span class="stringliteral">"  Interval: %d\n"</span>, urb-&gt;interval);
00570         <span class="keywordflow">if</span> (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
00571                 <span class="keywordtype">int</span> i;
00572                 <span class="keywordflow">for</span> (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
00573                         DWC_PRINTF(<span class="stringliteral">"  ISO Desc %d:\n"</span>, i);
00574                         DWC_PRINTF(<span class="stringliteral">"    offset: %d, length %d\n"</span>,
00575                                    urb-&gt;iso_frame_desc[i].offset,
00576                                    urb-&gt;iso_frame_desc[i].length);
00577                 }
00578         }
00579 }
00580 
00581 <span class="preprocessor">#endif</span>
00582 <span class="preprocessor"></span>
<a name="l00586"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a4">00586</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a4">urb_enqueue</a>(<span class="keyword">struct</span> usb_hcd *hcd,
00587 #<span class="keywordflow">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)
00588                        <span class="keyword">struct</span> usb_host_endpoint *ep,
00589 #endif
00590                        <span class="keyword">struct</span> urb *urb, gfp_t mem_flags)
00591 {
00592         <span class="keywordtype">int</span> retval = 0;
00593 <span class="preprocessor">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,28)</span>
00594 <span class="preprocessor"></span>        <span class="keyword">struct </span>usb_host_endpoint *ep = urb-&gt;ep;
00595 <span class="preprocessor">#endif</span>
00596 <span class="preprocessor"></span>        <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a> = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00597         dwc_otg_hcd_urb_t *dwc_otg_urb;
00598         <span class="keywordtype">int</span> i;
00599         <span class="keywordtype">int</span> alloc_bandwidth = 0;
00600         uint8_t ep_type = 0;
00601         uint32_t flags = 0;
00602         <span class="keywordtype">void</span> *buf;
00603 
00604 <span class="preprocessor">#ifdef DEBUG</span>
00605 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CHK_DEBUG_LEVEL(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a> | <a class="code" href="dwc__otg__dbg_8h.html#a6">DBG_HCD_URB</a>)) {
00606                 dump_urb_info(urb, <span class="stringliteral">"urb_enqueue"</span>);
00607         }
00608 <span class="preprocessor">#endif</span>
00609 <span class="preprocessor"></span>
00610         <span class="keywordflow">if</span> ((usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
00611             || (usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT)) {
00612                 <span class="keywordflow">if</span> (!<a class="code" href="dwc__otg__hcd_8c.html#a49">dwc_otg_hcd_is_bandwidth_allocated</a>
00613                     (dwc_otg_hcd, &amp;ep-&gt;hcpriv)) {
00614                         alloc_bandwidth = 1;
00615                 }
00616         }
00617 
00618         <span class="keywordflow">switch</span> (usb_pipetype(urb-&gt;pipe)) {
00619         <span class="keywordflow">case</span> PIPE_CONTROL:
00620                 ep_type = USB_ENDPOINT_XFER_CONTROL;
00621                 <span class="keywordflow">break</span>;
00622         <span class="keywordflow">case</span> PIPE_ISOCHRONOUS:
00623                 ep_type = USB_ENDPOINT_XFER_ISOC;
00624                 <span class="keywordflow">break</span>;
00625         <span class="keywordflow">case</span> PIPE_BULK:
00626                 ep_type = USB_ENDPOINT_XFER_BULK;
00627                 <span class="keywordflow">break</span>;
00628         <span class="keywordflow">case</span> PIPE_INTERRUPT:
00629                 ep_type = USB_ENDPOINT_XFER_INT;
00630                 <span class="keywordflow">break</span>;
00631         <span class="keywordflow">default</span>:
00632                 DWC_WARN(<span class="stringliteral">"Wrong ep type\n"</span>);
00633         }
00634 
00635         dwc_otg_urb = <a class="code" href="dwc__otg__hcd__if_8h.html#a26">dwc_otg_hcd_urb_alloc</a>(dwc_otg_hcd,
00636                                             urb-&gt;number_of_packets,
00637                                             mem_flags == GFP_ATOMIC ? 1 : 0);
00638 
00639         <a class="code" href="dwc__otg__hcd__if_8h.html#a27">dwc_otg_hcd_urb_set_pipeinfo</a>(dwc_otg_urb, usb_pipedevice(urb-&gt;pipe),
00640                                      usb_pipeendpoint(urb-&gt;pipe), ep_type,
00641                                      usb_pipein(urb-&gt;pipe),
00642                                      usb_maxpacket(urb-&gt;dev, urb-&gt;pipe,
00643                                                    !(usb_pipein(urb-&gt;pipe))));
00644 
00645         buf = urb-&gt;transfer_buffer;
00646         <span class="keywordflow">if</span> (hcd-&gt;self.uses_dma) {
00647                 <span class="comment">/*</span>
00648 <span class="comment">                 * Calculate virtual address from physical address,</span>
00649 <span class="comment">                 * because some class driver may not fill transfer_buffer.</span>
00650 <span class="comment">                 * In Buffer DMA mode virual address is used,</span>
00651 <span class="comment">                 * when handling non DWORD aligned buffers.</span>
00652 <span class="comment">                 */</span>
00653                 buf = phys_to_virt(urb-&gt;transfer_dma);
00654         }
00655 
00656         <span class="keywordflow">if</span> (!(urb-&gt;transfer_flags &amp; URB_NO_INTERRUPT))
00657                 flags |= URB_GIVEBACK_ASAP;
00658         <span class="keywordflow">if</span> (urb-&gt;transfer_flags &amp; URB_ZERO_PACKET)
00659                 flags |= URB_SEND_ZERO_PACKET;
00660 
00661         <a class="code" href="dwc__otg__hcd__if_8h.html#a28">dwc_otg_hcd_urb_set_params</a>(dwc_otg_urb, urb, buf,
00662                                    urb-&gt;transfer_dma,
00663                                    urb-&gt;transfer_buffer_length,
00664                                    urb-&gt;setup_packet,
00665                                    urb-&gt;setup_dma, flags, urb-&gt;interval);
00666 
00667         <span class="keywordflow">for</span> (i = 0; i &lt; urb-&gt;number_of_packets; ++i) {
00668                 <a class="code" href="dwc__otg__hcd__if_8h.html#a32">dwc_otg_hcd_urb_set_iso_desc_params</a>(dwc_otg_urb, i,
00669                                                     urb-&gt;
00670                                                     iso_frame_desc[i].offset,
00671                                                     urb-&gt;
00672                                                     iso_frame_desc[i].length);
00673         }
00674 
00675         urb-&gt;hcpriv = dwc_otg_urb;
00676         retval = <a class="code" href="dwc__otg__hcd__if_8h.html#a35">dwc_otg_hcd_urb_enqueue</a>(dwc_otg_hcd, dwc_otg_urb, &amp;ep-&gt;hcpriv,
00677                                          mem_flags == GFP_ATOMIC ? 1 : 0);
00678         <span class="keywordflow">if</span> (!retval) {
00679                 <span class="keywordflow">if</span> (alloc_bandwidth) {
00680                         allocate_bus_bandwidth(hcd,
00681                                                <a class="code" href="dwc__otg__hcd_8c.html#a51">dwc_otg_hcd_get_ep_bandwidth</a>
00682                                                (dwc_otg_hcd, ep-&gt;hcpriv), urb);
00683                 }
00684         } <span class="keywordflow">else</span> {
00685                 <span class="keywordflow">if</span> (retval == -DWC_E_NO_DEVICE) {
00686                         retval = -ENODEV;
00687                 }
00688         }
00689 
00690         <span class="keywordflow">return</span> retval;
00691 }
00692 
00695 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00696 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a5">urb_dequeue</a>(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> urb *urb)
00697 #<span class="keywordflow">else</span>
<a name="l00698"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a5">00698</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a5">urb_dequeue</a>(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> urb *urb, <span class="keywordtype">int</span> status)
00699 #endif
00700 {
00701         dwc_irqflags_t flags;
00702         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a>;
00703         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(<a class="code" href="dwc__otg__dbg_8h.html#a4">DBG_HCD</a>, <span class="stringliteral">"DWC OTG HCD URB Dequeue\n"</span>);
00704 
00705         dwc_otg_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00706 
00707 <span class="preprocessor">#ifdef DEBUG</span>
00708 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CHK_DEBUG_LEVEL(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a> | <a class="code" href="dwc__otg__dbg_8h.html#a6">DBG_HCD_URB</a>)) {
00709                 dump_urb_info(urb, <span class="stringliteral">"urb_dequeue"</span>);
00710         }
00711 <span class="preprocessor">#endif</span>
00712 <span class="preprocessor"></span>
00713         DWC_SPINLOCK_IRQSAVE(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>, &amp;flags);
00714 
00715         <a class="code" href="dwc__otg__hcd__if_8h.html#a36">dwc_otg_hcd_urb_dequeue</a>(dwc_otg_hcd, urb-&gt;hcpriv);
00716 
00717         DWC_FREE(urb-&gt;hcpriv);
00718         urb-&gt;hcpriv = NULL;
00719         DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>, flags);
00720 
00721         <span class="comment">/* Higher layer software sets URB status. */</span>
00722 <span class="preprocessor">#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2,6,28)</span>
00723 <span class="preprocessor"></span>        usb_hcd_giveback_urb(hcd, urb);
00724 <span class="preprocessor">#else</span>
00725 <span class="preprocessor"></span>        usb_hcd_giveback_urb(hcd, urb, status);
00726 <span class="preprocessor">#endif</span>
00727 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (CHK_DEBUG_LEVEL(<a class="code" href="dwc__otg__dbg_8h.html#a5">DBG_HCDV</a> | <a class="code" href="dwc__otg__dbg_8h.html#a6">DBG_HCD_URB</a>)) {
00728                 DWC_PRINTF(<span class="stringliteral">"Called usb_hcd_giveback_urb()\n"</span>);
00729                 DWC_PRINTF(<span class="stringliteral">"  urb-&gt;status = %d\n"</span>, urb-&gt;status);
00730         }
00731 
00732         <span class="keywordflow">return</span> 0;
00733 }
00734 
00735 <span class="comment">/* Frees resources in the DWC_otg controller related to a given endpoint. Also</span>
00736 <span class="comment"> * clears state in the HCD related to the endpoint. Any URBs for the endpoint</span>
00737 <span class="comment"> * must already be dequeued. */</span>
00738 <span class="keyword">static</span> <span class="keywordtype">void</span> endpoint_disable(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> usb_host_endpoint *ep)
00739 {
00740         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd</a> = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00741 
00742         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCD,
00743                     <span class="stringliteral">"DWC OTG HCD EP DISABLE: _bEndpointAddress=0x%02x, "</span>
00744                     <span class="stringliteral">"endpoint=%d\n"</span>, ep-&gt;desc.bEndpointAddress,
00745                     <a class="code" href="dwc__otg__hcd__linux_8c.html#a0">dwc_ep_addr_to_endpoint</a>(ep-&gt;desc.bEndpointAddress));
00746         <a class="code" href="dwc__otg__hcd__if_8h.html#a37">dwc_otg_hcd_endpoint_disable</a>(dwc_otg_hcd, ep-&gt;hcpriv, 250);
00747         ep-&gt;hcpriv = NULL;
00748 }
00749 
00750 <span class="preprocessor">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,30)</span>
00751 <span class="preprocessor"></span><span class="comment">/* Resets endpoint specific parameter values, in current version used to reset </span>
00752 <span class="comment"> * the data toggle(as a WA). This function can be called from usb_clear_halt routine */</span>
00753 <span class="keyword">static</span> <span class="keywordtype">void</span> endpoint_reset(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keyword">struct</span> usb_host_endpoint *ep)
00754 {
00755         dwc_irqflags_t flags;
00756         <span class="keyword">struct </span>usb_device *udev = NULL;
00757         <span class="keywordtype">int</span> epnum = usb_endpoint_num(&amp;ep-&gt;desc);
00758         <span class="keywordtype">int</span> is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
00759         <span class="keywordtype">int</span> is_control = usb_endpoint_xfer_control(&amp;ep-&gt;desc);
00760         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *dwc_otg_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00761 <span class="preprocessor">#ifdef LM_INTERFACE</span>
00762 <span class="preprocessor"></span>        <span class="keyword">struct </span>lm_device *_dev = dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o0">otg_dev</a>-&gt;<a class="code" href="structdwc__otg__device.html#o0">os_dep</a>.lmdev;
00763 <span class="preprocessor">#elif defined(PCI_INTERFACE)</span>
00764 <span class="preprocessor"></span>        <span class="keyword">struct </span>pci_dev *_dev = dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o0">otg_dev</a>-&gt;<a class="code" href="structdwc__otg__device.html#o0">os_dep</a>.pcidev;
00765 <span class="preprocessor">#endif</span>
00766 <span class="preprocessor"></span>
00767         <span class="keywordflow">if</span> (_dev)
00768                 udev = to_usb_device(&amp;_dev-&gt;dev);
00769         <span class="keywordflow">else</span>
00770                 <span class="keywordflow">return</span>;
00771 
00772         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCD, <span class="stringliteral">"DWC OTG HCD EP RESET: Endpoint Num=0x%02d\n"</span>, epnum);
00773 
00774         DWC_SPINLOCK_IRQSAVE(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>, &amp;flags);
00775         usb_settoggle(udev, epnum, is_out, 0);
00776         <span class="keywordflow">if</span> (is_control)
00777                 usb_settoggle(udev, epnum, !is_out, 0);
00778 
00779         <span class="keywordflow">if</span> (ep-&gt;hcpriv) {
00780                 dwc_otg_hcd_endpoint_reset(dwc_otg_hcd, ep-&gt;hcpriv);
00781         }
00782         DWC_SPINUNLOCK_IRQRESTORE(dwc_otg_hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o22">lock</a>, flags);
00783 }
00784 <span class="preprocessor">#endif</span>
00785 <span class="preprocessor"></span>
<a name="l00791"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a8">00791</a> <span class="keyword">static</span> irqreturn_t <a class="code" href="dwc__otg__hcd__linux_8c.html#a8">dwc_otg_hcd_irq</a>(<span class="keyword">struct</span> usb_hcd *hcd)
00792 {
00793         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *dwc_otg_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00794         int32_t retval = <a class="code" href="dwc__otg__hcd__intr_8c.html#a0">dwc_otg_hcd_handle_intr</a>(dwc_otg_hcd);
00795         <span class="keywordflow">if</span> (retval != 0) {
00796                 S3C2410X_CLEAR_EINTPEND();
00797         }
00798         <span class="keywordflow">return</span> IRQ_RETVAL(retval);
00799 }
00800 
<a name="l00805"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a12">00805</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a12">hub_status_data</a>(<span class="keyword">struct</span> usb_hcd *hcd, <span class="keywordtype">char</span> *buf)
00806 {
00807         <a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> *dwc_otg_hcd = <a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd);
00808 
00809         buf[0] = 0;
00810         buf[0] |= (<a class="code" href="dwc__otg__hcd__if_8h.html#a39">dwc_otg_hcd_is_status_changed</a>(dwc_otg_hcd, 1)) &lt;&lt; 1;
00811 
00812         <span class="keywordflow">return</span> (buf[0] != 0);
00813 }
00814 
<a name="l00816"></a><a class="code" href="dwc__otg__hcd__linux_8c.html#a13">00816</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__linux_8c.html#a13">hub_control</a>(<span class="keyword">struct</span> usb_hcd *hcd,
00817                 u16 typeReq, u16 wValue, u16 wIndex, <span class="keywordtype">char</span> *buf, u16 wLength)
00818 {
00819         <span class="keywordtype">int</span> retval;
00820 
00821         retval = <a class="code" href="dwc__otg__hcd__if_8h.html#a18">dwc_otg_hcd_hub_control</a>(<a class="code" href="dwc__otg__hcd__linux_8c.html#a14">hcd_to_dwc_otg_hcd</a>(hcd),
00822                                          typeReq, wValue, wIndex, buf, wLength);
00823 
00824         <span class="keywordflow">switch</span> (retval) {
00825         <span class="keywordflow">case</span> -DWC_E_INVALID:
00826                 retval = -EINVAL;
00827                 <span class="keywordflow">break</span>;
00828         }
00829 
00830         <span class="keywordflow">return</span> retval;
00831 }
00832 
00833 <span class="preprocessor">#endif </span><span class="comment">/* DWC_DEVICE_ONLY */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 27 03:56:37 2011 for DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>

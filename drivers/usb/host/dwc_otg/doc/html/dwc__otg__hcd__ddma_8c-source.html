<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver: dwc_otg_hcd_ddma.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>dwc_otg_hcd_ddma.c</h1><a href="dwc__otg__hcd__ddma_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*==========================================================================</span>
00002 <span class="comment"> * $File: //dwh/usb_iip/dev/software/otg/linux/drivers/dwc_otg_hcd_ddma.c $</span>
00003 <span class="comment"> * $Revision: #10 $</span>
00004 <span class="comment"> * $Date: 2011/10/20 $</span>
00005 <span class="comment"> * $Change: 1869464 $</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * Synopsys HS OTG Linux Software Driver and documentation (hereinafter,</span>
00008 <span class="comment"> * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless</span>
00009 <span class="comment"> * otherwise expressly agreed to in writing between Synopsys and you.</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * The Software IS NOT an item of Licensed Software or Licensed Product under</span>
00012 <span class="comment"> * any End User Software License Agreement or Agreement for Licensed Product</span>
00013 <span class="comment"> * with Synopsys or any supplement thereto. You are permitted to use and</span>
00014 <span class="comment"> * redistribute this Software in source and binary forms, with or without</span>
00015 <span class="comment"> * modification, provided that redistributions of source code must retain this</span>
00016 <span class="comment"> * notice. You may not view, use, disclose, copy or distribute this file or</span>
00017 <span class="comment"> * any information contained herein except pursuant to this license grant from</span>
00018 <span class="comment"> * Synopsys. If you do not agree with this notice, including the disclaimer</span>
00019 <span class="comment"> * below, then you are not authorized to use the Software.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS</span>
00022 <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
00023 <span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
00024 <span class="comment"> * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,</span>
00025 <span class="comment"> * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
00026 <span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
00027 <span class="comment"> * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
00028 <span class="comment"> * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
00029 <span class="comment"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
00030 <span class="comment"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH</span>
00031 <span class="comment"> * DAMAGE.</span>
00032 <span class="comment"> * ========================================================================== */</span>
00033 <span class="preprocessor">#ifndef DWC_DEVICE_ONLY</span>
00034 <span class="preprocessor"></span>
00039 <span class="preprocessor">#include "<a class="code" href="dwc__otg__hcd_8h.html">dwc_otg_hcd.h</a>"</span>
00040 <span class="preprocessor">#include "<a class="code" href="dwc__otg__regs_8h.html">dwc_otg_regs.h</a>"</span>
00041 
00042 <span class="keyword">static</span> <span class="keyword">inline</span> uint8_t frame_list_idx(uint16_t frame)
00043 {
00044         <span class="keywordflow">return</span> (frame &amp; (MAX_FRLIST_EN_NUM - 1));
00045 }
00046 
00047 <span class="keyword">static</span> <span class="keyword">inline</span> uint16_t desclist_idx_inc(uint16_t idx, uint16_t inc, uint8_t speed)
00048 {
00049         <span class="keywordflow">return</span> (idx + inc) &amp;
00050             (((speed ==
00051                DWC_OTG_EP_SPEED_HIGH) ? MAX_DMA_DESC_NUM_HS_ISOC :
00052               MAX_DMA_DESC_NUM_GENERIC) - 1);
00053 }
00054 
00055 <span class="keyword">static</span> <span class="keyword">inline</span> uint16_t desclist_idx_dec(uint16_t idx, uint16_t inc, uint8_t speed)
00056 {
00057         <span class="keywordflow">return</span> (idx - inc) &amp;
00058             (((speed ==
00059                DWC_OTG_EP_SPEED_HIGH) ? MAX_DMA_DESC_NUM_HS_ISOC :
00060               MAX_DMA_DESC_NUM_GENERIC) - 1);
00061 }
00062 
00063 <span class="keyword">static</span> <span class="keyword">inline</span> uint16_t max_desc_num(<a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00064 {
00065         <span class="keywordflow">return</span> (((qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_ISOCHRONOUS)
00066                  &amp;&amp; (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a> == DWC_OTG_EP_SPEED_HIGH))
00067                 ? MAX_DMA_DESC_NUM_HS_ISOC : MAX_DMA_DESC_NUM_GENERIC);
00068 }
00069 <span class="keyword">static</span> <span class="keyword">inline</span> uint16_t frame_incr_val(<a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00070 {
00071         <span class="keywordflow">return</span> ((qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a> == DWC_OTG_EP_SPEED_HIGH)
00072                 ? ((qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a> + 8 - 1) / 8)
00073                 : qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>);
00074 }
00075 
00076 <span class="keyword">static</span> <span class="keywordtype">int</span> desc_list_alloc(<a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00077 {
00078         <span class="keywordtype">int</span> retval = 0;
00079 
00080         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a> = (<a class="code" href="structdwc__otg__host__dma__desc.html">dwc_otg_host_dma_desc_t</a> *)
00081             DWC_DMA_ALLOC(<span class="keyword">sizeof</span>(<a class="code" href="structdwc__otg__host__dma__desc.html">dwc_otg_host_dma_desc_t</a>) * max_desc_num(qh),
00082                           &amp;qh-&gt;desc_list_dma);
00083 
00084         <span class="keywordflow">if</span> (!qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>) {
00085                 retval = -DWC_E_NO_MEMORY;
00086                 DWC_ERROR(<span class="stringliteral">"%s: DMA descriptor list allocation failed\n"</span>, __func__);
00087                 
00088         }
00089 
00090         dwc_memset(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>, 0x00,
00091                    <span class="keyword">sizeof</span>(dwc_otg_host_dma_desc_t) * max_desc_num(qh));
00092 
00093         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a> =
00094             (uint32_t *) DWC_ALLOC(<span class="keyword">sizeof</span>(uint32_t) * max_desc_num(qh));
00095 
00096         <span class="keywordflow">if</span> (!qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>) {
00097                 retval = -DWC_E_NO_MEMORY;
00098                 DWC_ERROR
00099                     (<span class="stringliteral">"%s: Failed to allocate array for descriptors' size actual values\n"</span>,
00100                      __func__);
00101 
00102         }
00103         <span class="keywordflow">return</span> retval;
00104 
00105 }
00106 
00107 <span class="keyword">static</span> <span class="keywordtype">void</span> desc_list_free(<a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00108 {
00109         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>) {
00110                 DWC_DMA_FREE(max_desc_num(qh), qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>,
00111                              qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_1">desc_list_dma</a>);
00112                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a> = NULL;
00113         }
00114 
00115         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>) {
00116                 DWC_FREE(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>);
00117                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a> = NULL;
00118         }
00119 }
00120 
00121 <span class="keyword">static</span> <span class="keywordtype">int</span> frame_list_alloc(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00122 {
00123         <span class="keywordtype">int</span> retval = 0;
00124         <span class="keywordflow">if</span> (hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>)
00125                 <span class="keywordflow">return</span> 0;
00126 
00127         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a> = DWC_DMA_ALLOC(4 * MAX_FRLIST_EN_NUM,
00128                                         &amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o26">frame_list_dma</a>);
00129         <span class="keywordflow">if</span> (!hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>) {
00130                 retval = -DWC_E_NO_MEMORY;
00131                 DWC_ERROR(<span class="stringliteral">"%s: Frame List allocation failed\n"</span>, __func__);
00132         }
00133 
00134         dwc_memset(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>, 0x00, 4 * MAX_FRLIST_EN_NUM);
00135 
00136         <span class="keywordflow">return</span> retval;
00137 }
00138 
00139 <span class="keyword">static</span> <span class="keywordtype">void</span> frame_list_free(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00140 {
00141         <span class="keywordflow">if</span> (!hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>)
00142                 <span class="keywordflow">return</span>;
00143         
00144         DWC_DMA_FREE(4 * MAX_FRLIST_EN_NUM, hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>, hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o26">frame_list_dma</a>);
00145         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a> = NULL;
00146 }
00147 
00148 <span class="keyword">static</span> <span class="keywordtype">void</span> per_sched_enable(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, uint16_t fr_list_en)
00149 {
00150 
00151         <a class="code" href="unionhcfg__data.html">hcfg_data_t</a> hcfg;
00152 
00153         hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>);
00154 
00155         <span class="keywordflow">if</span> (hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o9">perschedena</a>) {
00156                 <span class="comment">/* already enabled */</span>
00157                 <span class="keywordflow">return</span>;
00158         }
00159 
00160         DWC_WRITE_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o7">hflbaddr</a>,
00161                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o26">frame_list_dma</a>);
00162 
00163         <span class="keywordflow">switch</span> (fr_list_en) {
00164         <span class="keywordflow">case</span> 64:
00165                 hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o8">frlisten</a> = 3;
00166                 <span class="keywordflow">break</span>;
00167         <span class="keywordflow">case</span> 32:
00168                 hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o8">frlisten</a> = 2;
00169                 <span class="keywordflow">break</span>;
00170         <span class="keywordflow">case</span> 16:
00171                 hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o8">frlisten</a> = 1;
00172                 <span class="keywordflow">break</span>;
00173         <span class="keywordflow">case</span> 8:
00174                 hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o8">frlisten</a> = 0;
00175                 <span class="keywordflow">break</span>;
00176         <span class="keywordflow">default</span>:
00177                 <span class="keywordflow">break</span>;
00178         }
00179 
00180         hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o9">perschedena</a> = 1;
00181 
00182         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCD, <span class="stringliteral">"Enabling Periodic schedule\n"</span>);
00183         DWC_WRITE_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>, hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a>);
00184 
00185 }
00186 
00187 <span class="keyword">static</span> <span class="keywordtype">void</span> per_sched_disable(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00188 {
00189         <a class="code" href="unionhcfg__data.html">hcfg_data_t</a> hcfg;
00190 
00191         hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>);
00192         
00193         <span class="keywordflow">if</span> (!hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o9">perschedena</a>) {
00194                 <span class="comment">/* already disabled */</span>
00195                 <span class="keywordflow">return</span>;
00196         }
00197         hcfg.<a class="code" href="unionhcfg__data.html#o12">b</a>.<a class="code" href="unionhcfg__data.html#o9">perschedena</a> = 0;
00198 
00199         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCD, <span class="stringliteral">"Disabling Periodic schedule\n"</span>);
00200         DWC_WRITE_REG32(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>-&gt;<a class="code" href="structdwc__otg__core__if.html#o3">host_if</a>-&gt;<a class="code" href="structdwc__otg__host__if.html#o0">host_global_regs</a>-&gt;<a class="code" href="structdwc__otg__host__global__regs.html#o0">hcfg</a>, hcfg.<a class="code" href="unionhcfg__data.html#o0">d32</a>);
00201 }
00202 
00203 <span class="comment">/* </span>
00204 <span class="comment"> * Activates/Deactivates FrameList entries for the channel </span>
00205 <span class="comment"> * based on endpoint servicing period.</span>
00206 <span class="comment"> */</span>
00207 <span class="keywordtype">void</span> update_frame_list(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh, uint8_t enable)
00208 {
00209         uint16_t i, j, inc;
00210         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> *hc = NULL;
00211 
00212         <span class="keywordflow">if</span> (!qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>) {
00213                 DWC_ERROR(<span class="stringliteral">"qh-&gt;channel = %p"</span>, qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>);
00214                 <span class="keywordflow">return</span>;
00215         }
00216 
00217         <span class="keywordflow">if</span> (!hcd) {
00218                 DWC_ERROR(<span class="stringliteral">"------hcd = %p"</span>, hcd);
00219                 <span class="keywordflow">return</span>;
00220         }
00221 
00222         <span class="keywordflow">if</span> (!hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>) {
00223                 DWC_ERROR(<span class="stringliteral">"-------hcd-&gt;frame_list = %p"</span>, hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>);
00224                 <span class="keywordflow">return</span>;
00225         }
00226 
00227         hc = qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>;
00228         inc = frame_incr_val(qh);
00229         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_ISOCHRONOUS)
00230                 i = frame_list_idx(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_2">sched_frame</a>);
00231         <span class="keywordflow">else</span>
00232                 i = 0;
00233 
00234         j = i;
00235         <span class="keywordflow">do</span> {
00236                 <span class="keywordflow">if</span> (enable)
00237                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>[j] |= (1 &lt;&lt; hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
00238                 <span class="keywordflow">else</span>
00239                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>[j] &amp;= ~(1 &lt;&lt; hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
00240                 j = (j + inc) &amp; (MAX_FRLIST_EN_NUM - 1);
00241         }
00242         <span class="keywordflow">while</span> (j != i);
00243         <span class="keywordflow">if</span> (!enable)
00244                 <span class="keywordflow">return</span>;
00245         hc-&gt;<a class="code" href="structdwc__hc.html#z36_2">schinfo</a> = 0;
00246         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a> == DWC_OTG_EP_SPEED_HIGH) {
00247                 j = 1;
00248                 <span class="comment">/* TODO - check this */</span>
00249                 inc = (8 + qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a> - 1) / qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>;
00250                 <span class="keywordflow">for</span> (i = 0; i &lt; inc; i++) {
00251                         hc-&gt;<a class="code" href="structdwc__hc.html#z36_2">schinfo</a> |= j;
00252                         j = j &lt;&lt; qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>;
00253                 }
00254         } <span class="keywordflow">else</span> {
00255                 hc-&gt;<a class="code" href="structdwc__hc.html#z36_2">schinfo</a> = 0xff;
00256         }
00257 }
00258 
00259 <span class="preprocessor">#if 1</span>
00260 <span class="preprocessor"></span><span class="keywordtype">void</span> dump_frame_list(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd)
00261 {
00262         <span class="keywordtype">int</span> i = 0;
00263         DWC_PRINTF(<span class="stringliteral">"--FRAME LIST (hex) --\n"</span>);
00264         <span class="keywordflow">for</span> (i = 0; i &lt; MAX_FRLIST_EN_NUM; i++) {
00265                 DWC_PRINTF(<span class="stringliteral">"%x\t"</span>, hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>[i]);
00266                 <span class="keywordflow">if</span> (!(i % 8) &amp;&amp; i)
00267                         DWC_PRINTF(<span class="stringliteral">"\n"</span>);
00268         }
00269         DWC_PRINTF(<span class="stringliteral">"\n----\n"</span>);
00270 
00271 }
00272 <span class="preprocessor">#endif</span>
00273 <span class="preprocessor"></span>
00274 <span class="keyword">static</span> <span class="keywordtype">void</span> release_channel_ddma(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00275 {
00276         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> *hc = qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>;
00277         <span class="keywordflow">if</span> (<a class="code" href="dwc__otg__hcd_8h.html#a3">dwc_qh_is_non_per</a>(qh))
00278                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o16">non_periodic_channels</a>--;
00279         <span class="keywordflow">else</span>
00280                 update_frame_list(hcd, qh, 0);
00281 
00282         <span class="comment">/* </span>
00283 <span class="comment">         * The condition is added to prevent double cleanup try in case of device</span>
00284 <span class="comment">         * disconnect. See channel cleanup in dwc_otg_hcd_disconnect_cb().</span>
00285 <span class="comment">         */</span>
00286         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>) {
00287                 <a class="code" href="dwc__otg__cil_8h.html#a93">dwc_otg_hc_cleanup</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc);
00288                 DWC_CIRCLEQ_INSERT_TAIL(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o14">free_hc_list</a>, hc, hc_list_entry);
00289                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a> = NULL;
00290         }
00291 
00292         qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a> = NULL;
00293         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a> = 0;
00294 
00295         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>) {
00296                 dwc_memset(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>, 0x00,
00297                            <span class="keyword">sizeof</span>(dwc_otg_host_dma_desc_t) * max_desc_num(qh));
00298         }
00299 }
00300 
<a name="l00312"></a><a class="code" href="dwc__otg__hcd__ddma_8c.html#a18">00312</a> <span class="keywordtype">int</span> <a class="code" href="dwc__otg__hcd__ddma_8c.html#a18">dwc_otg_hcd_qh_init_ddma</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00313 {
00314         <span class="keywordtype">int</span> retval = 0;
00315 
00316         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o8">do_split</a>) {
00317                 DWC_ERROR(<span class="stringliteral">"SPLIT Transfers are not supported in Descriptor DMA.\n"</span>);
00318                 <span class="keywordflow">return</span> -1;
00319         }
00320 
00321         retval = desc_list_alloc(qh);
00322 
00323         <span class="keywordflow">if</span> ((retval == 0)
00324             &amp;&amp; (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_ISOCHRONOUS || qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_INTERRUPT)) {
00325                 <span class="keywordflow">if</span> (!hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>) {
00326                         retval = frame_list_alloc(hcd);
00327                         <span class="comment">/* Enable periodic schedule on first periodic QH */</span>
00328                         <span class="keywordflow">if</span> (retval == 0)
00329                                 per_sched_enable(hcd, MAX_FRLIST_EN_NUM);
00330                 }
00331         }
00332 
00333         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a> = 0;
00334 
00335         <span class="keywordflow">return</span> retval;
00336 }
00337 
<a name="l00346"></a><a class="code" href="dwc__otg__hcd__ddma_8c.html#a19">00346</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__ddma_8c.html#a19">dwc_otg_hcd_qh_free_ddma</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00347 {
00348         desc_list_free(qh);
00349 
00350         <span class="comment">/* </span>
00351 <span class="comment">         * Channel still assigned due to some reasons. </span>
00352 <span class="comment">         * Seen on Isoc URB dequeue. Channel halted but no subsequent</span>
00353 <span class="comment">         * ChHalted interrupt to release the channel. Afterwards</span>
00354 <span class="comment">         * when it comes here from endpoint disable routine</span>
00355 <span class="comment">         * channel remains assigned.</span>
00356 <span class="comment">         */</span>
00357         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>)
00358                 release_channel_ddma(hcd, qh);
00359 
00360         <span class="keywordflow">if</span> ((qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_ISOCHRONOUS || qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_INTERRUPT)
00361             &amp;&amp; !hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o15">periodic_channels</a> &amp;&amp; hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o25">frame_list</a>) {
00362 
00363                 per_sched_disable(hcd);
00364                 frame_list_free(hcd);
00365         }
00366 }
00367 
00368 <span class="keyword">static</span> uint8_t frame_to_desc_idx(<a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh, uint16_t frame_idx)
00369 {
00370         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a> == DWC_OTG_EP_SPEED_HIGH) {
00371                 <span class="comment">/* </span>
00372 <span class="comment">                 * Descriptor set(8 descriptors) index</span>
00373 <span class="comment">                 * which is 8-aligned.</span>
00374 <span class="comment">                 */</span>
00375                 <span class="keywordflow">return</span> (frame_idx &amp; ((MAX_DMA_DESC_NUM_HS_ISOC / 8) - 1)) * 8;
00376         } <span class="keywordflow">else</span> {
00377                 <span class="keywordflow">return</span> (frame_idx &amp; (MAX_DMA_DESC_NUM_GENERIC - 1));
00378         }
00379 }
00380 
00381 <span class="comment">/* </span>
00382 <span class="comment"> * Determine starting frame for Isochronous transfer. </span>
00383 <span class="comment"> * Few frames skipped to prevent race condition with HC. </span>
00384 <span class="comment"> */</span>
00385 <span class="keyword">static</span> uint8_t calc_starting_frame(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh,
00386                                    uint8_t * skip_frames)
00387 {
00388         uint16_t frame = 0;
00389         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a> = <a class="code" href="dwc__otg__hcd__if_8h.html#a22">dwc_otg_hcd_get_frame_number</a>(hcd);
00390         
00391         <span class="comment">/* sched_frame is always frame number(not uFrame) both in FS and HS !! */</span>
00392         
00393         <span class="comment">/* </span>
00394 <span class="comment">         * skip_frames is used to limit activated descriptors number</span>
00395 <span class="comment">         * to avoid the situation when HC services the last activated</span>
00396 <span class="comment">         * descriptor firstly.</span>
00397 <span class="comment">         * Example for FS:</span>
00398 <span class="comment">         * Current frame is 1, scheduled frame is 3. Since HC always fetches the descriptor</span>
00399 <span class="comment">         * corresponding to curr_frame+1, the descriptor corresponding to frame 2</span>
00400 <span class="comment">         * will be fetched. If the number of descriptors is max=64 (or greather) the</span>
00401 <span class="comment">         * list will be fully programmed with Active descriptors and it is possible</span>
00402 <span class="comment">         * case(rare) that the latest descriptor(considering rollback) corresponding</span>
00403 <span class="comment">         * to frame 2 will be serviced first. HS case is more probable because, in fact,</span>
00404 <span class="comment">         * up to 11 uframes(16 in the code) may be skipped.</span>
00405 <span class="comment">         */</span>
00406         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a> == DWC_OTG_EP_SPEED_HIGH) {
00407                 <span class="comment">/* </span>
00408 <span class="comment">                 * Consider uframe counter also, to start xfer asap.</span>
00409 <span class="comment">                 * If half of the frame elapsed skip 2 frames otherwise</span>
00410 <span class="comment">                 * just 1 frame. </span>
00411 <span class="comment">                 * Starting descriptor index must be 8-aligned, so</span>
00412 <span class="comment">                 * if the current frame is near to complete the next one</span>
00413 <span class="comment">                 * is skipped as well.</span>
00414 <span class="comment">                 */</span>
00415 
00416                 <span class="keywordflow">if</span> (dwc_micro_frame_num(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a>) &gt;= 5) {
00417                         *skip_frames = 2 * 8;
00418                         frame = <a class="code" href="dwc__otg__hcd_8h.html#a67">dwc_frame_num_inc</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a>, *skip_frames);
00419                 } <span class="keywordflow">else</span> {
00420                         *skip_frames = 1 * 8;
00421                         frame = <a class="code" href="dwc__otg__hcd_8h.html#a67">dwc_frame_num_inc</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a>, *skip_frames);
00422                 }
00423 
00424                 frame = dwc_full_frame_num(frame);
00425         } <span class="keywordflow">else</span> {
00426                 <span class="comment">/* </span>
00427 <span class="comment">                 * Two frames are skipped for FS - the current and the next.</span>
00428 <span class="comment">                 * But for descriptor programming, 1 frame(descriptor) is enough,</span>
00429 <span class="comment">                 * see example above.</span>
00430 <span class="comment">                 */</span>
00431                 *skip_frames = 1;
00432                 frame = <a class="code" href="dwc__otg__hcd_8h.html#a67">dwc_frame_num_inc</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o12">frame_number</a>, 2);
00433         }
00434 
00435         <span class="keywordflow">return</span> frame;
00436 }
00437 
00438 <span class="comment">/* </span>
00439 <span class="comment"> * Calculate initial descriptor index for isochronous transfer</span>
00440 <span class="comment"> * based on scheduled frame. </span>
00441 <span class="comment"> */</span>
00442 <span class="keyword">static</span> uint8_t recalc_initial_desc_idx(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00443 {
00444         uint16_t frame = 0, fr_idx, fr_idx_tmp;
00445         uint8_t skip_frames = 0;
00446         <span class="comment">/* </span>
00447 <span class="comment">         * With current ISOC processing algorithm the channel is being</span>
00448 <span class="comment">         * released when no more QTDs in the list(qh-&gt;ntd == 0).</span>
00449 <span class="comment">         * Thus this function is called only when qh-&gt;ntd == 0 and qh-&gt;channel == 0. </span>
00450 <span class="comment">         *</span>
00451 <span class="comment">         * So qh-&gt;channel != NULL branch is not used and just not removed from the</span>
00452 <span class="comment">         * source file. It is required for another possible approach which is,</span>
00453 <span class="comment">         * do not disable and release the channel when ISOC session completed, </span>
00454 <span class="comment">         * just move QH to inactive schedule until new QTD arrives. </span>
00455 <span class="comment">         * On new QTD, the QH moved back to 'ready' schedule,</span>
00456 <span class="comment">         * starting frame and therefore starting desc_index are recalculated.</span>
00457 <span class="comment">         * In this case channel is released only on ep_disable.</span>
00458 <span class="comment">         */</span>
00459 
00460         <span class="comment">/* Calculate starting descriptor index. For INTERRUPT endpoint it is always 0. */</span>
00461         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>) {
00462                 frame = calc_starting_frame(hcd, qh, &amp;skip_frames);
00463                 <span class="comment">/* </span>
00464 <span class="comment">                 * Calculate initial descriptor index based on FrameList current bitmap</span>
00465 <span class="comment">                 * and servicing period.</span>
00466 <span class="comment">                 */</span>
00467                 fr_idx_tmp = frame_list_idx(frame);
00468                 fr_idx =
00469                     (MAX_FRLIST_EN_NUM + frame_list_idx(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_2">sched_frame</a>) -
00470                      fr_idx_tmp)
00471                     % frame_incr_val(qh);
00472                 fr_idx = (fr_idx + fr_idx_tmp) % MAX_FRLIST_EN_NUM;
00473         } <span class="keywordflow">else</span> {
00474                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_2">sched_frame</a> = calc_starting_frame(hcd, qh, &amp;skip_frames);
00475                 fr_idx = frame_list_idx(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_2">sched_frame</a>);
00476         }
00477 
00478         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_4">td_first</a> = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_5">td_last</a> = frame_to_desc_idx(qh, fr_idx);
00479 
00480         <span class="keywordflow">return</span> skip_frames;
00481 }
00482 
00483 <span class="preprocessor">#define ISOC_URB_GIVEBACK_ASAP</span>
00484 <span class="preprocessor"></span>
00485 <span class="preprocessor">#define MAX_ISOC_XFER_SIZE_FS 1023</span>
00486 <span class="preprocessor"></span><span class="preprocessor">#define MAX_ISOC_XFER_SIZE_HS 3072</span>
00487 <span class="preprocessor"></span><span class="preprocessor">#define DESCNUM_THRESHOLD 4</span>
00488 <span class="preprocessor"></span>
00489 <span class="keyword">static</span> <span class="keywordtype">void</span> init_isoc_dma_desc(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh,
00490                                uint8_t skip_frames)
00491 {
00492         <span class="keyword">struct </span>dwc_otg_hcd_iso_packet_desc *frame_desc;
00493         <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> *qtd;
00494         <a class="code" href="dwc__otg__regs_8h.html#a157">dwc_otg_host_dma_desc_t</a> *dma_desc;
00495         uint16_t idx, inc, n_desc, ntd_max, max_xfer_size;
00496 
00497         idx = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_5">td_last</a>;
00498         inc = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>;
00499         n_desc = 0;
00500 
00501         ntd_max = (max_desc_num(qh) + qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a> - 1) / qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>;
00502         <span class="keywordflow">if</span> (skip_frames &amp;&amp; !qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>)
00503                 ntd_max = ntd_max - skip_frames / qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>;
00504 
00505         max_xfer_size =
00506             (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a> ==
00507              DWC_OTG_EP_SPEED_HIGH) ? MAX_ISOC_XFER_SIZE_HS :
00508             MAX_ISOC_XFER_SIZE_FS;
00509 
00510         DWC_CIRCLEQ_FOREACH(qtd, &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry) {
00511                 <span class="keywordflow">while</span> ((qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a> &lt; ntd_max)
00512                        &amp;&amp; (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o12">isoc_frame_index_last</a> &lt;
00513                            qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;packet_count)) {
00514 
00515                         dma_desc = &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[idx];
00516                         dwc_memset(dma_desc, 0x00, <span class="keyword">sizeof</span>(dwc_otg_host_dma_desc_t));
00517 
00518                         frame_desc = &amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;iso_descs[qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o12">isoc_frame_index_last</a>];
00519 
00520                         <span class="keywordflow">if</span> (frame_desc-&gt;length &gt; max_xfer_size)
00521                                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[idx] = max_xfer_size;
00522                         <span class="keywordflow">else</span>
00523                                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[idx] = frame_desc-&gt;length;
00524                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o1">n_bytes</a> = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[idx];
00525                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o10">a</a> = 1;
00526                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o8">sts</a> = 0;
00527 
00528                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o1">buf</a> = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;dma + frame_desc-&gt;offset;
00529 
00530                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a>++;
00531 
00532                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o12">isoc_frame_index_last</a>++;
00533 
00534 <span class="preprocessor">#ifdef  ISOC_URB_GIVEBACK_ASAP</span>
00535 <span class="preprocessor"></span>                        <span class="comment">/* </span>
00536 <span class="comment">                         * Set IOC for each descriptor corresponding to the </span>
00537 <span class="comment">                         * last frame of the URB.</span>
00538 <span class="comment">                         */</span>
00539                         <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o12">isoc_frame_index_last</a> ==
00540                             qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;packet_count)
00541                                 dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o5">ioc</a> = 1;
00542 
00543 <span class="preprocessor">#endif</span>
00544 <span class="preprocessor"></span>                        idx = desclist_idx_inc(idx, inc, qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a>);
00545                         n_desc++;
00546 
00547                 }
00548                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o10">in_process</a> = 1;
00549         }
00550 
00551         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_5">td_last</a> = idx;
00552 
00553 <span class="preprocessor">#ifdef  ISOC_URB_GIVEBACK_ASAP</span>
00554 <span class="preprocessor"></span>        <span class="comment">/* Set IOC for the last descriptor if descriptor list is full */</span>
00555         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a> == ntd_max) {
00556                 idx = desclist_idx_dec(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_5">td_last</a>, inc, qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a>);
00557                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[idx].<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o5">ioc</a> = 1;
00558         }
00559 <span class="preprocessor">#else</span>
00560 <span class="preprocessor"></span>        <span class="comment">/* </span>
00561 <span class="comment">         * Set IOC bit only for one descriptor. </span>
00562 <span class="comment">         * Always try to be ahead of HW processing,</span>
00563 <span class="comment">         * i.e. on IOC generation driver activates next descriptors but</span>
00564 <span class="comment">         * core continues to process descriptors followed the one with IOC set.</span>
00565 <span class="comment">         */</span>
00566 
00567         <span class="keywordflow">if</span> (n_desc &gt; DESCNUM_THRESHOLD) {
00568                 <span class="comment">/* </span>
00569 <span class="comment">                 * Move IOC "up". Required even if there is only one QTD </span>
00570 <span class="comment">                 * in the list, cause QTDs migth continue to be queued,</span>
00571 <span class="comment">                 * but during the activation it was only one queued.</span>
00572 <span class="comment">                 * Actually more than one QTD might be in the list if this function called </span>
00573 <span class="comment">                 * from XferCompletion - QTDs was queued during HW processing of the previous</span>
00574 <span class="comment">                 * descriptor chunk.</span>
00575 <span class="comment">                 */</span>
00576                 idx = dwc_desclist_idx_dec(idx, inc * ((qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a> + 1) / 2), qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a>);
00577         } <span class="keywordflow">else</span> {
00578                 <span class="comment">/* </span>
00579 <span class="comment">                 * Set the IOC for the latest descriptor</span>
00580 <span class="comment">                 * if either number of descriptor is not greather than threshold</span>
00581 <span class="comment">                 * or no more new descriptors activated.</span>
00582 <span class="comment">                 */</span>
00583                 idx = dwc_desclist_idx_dec(qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_5">td_last</a>, inc, qh-&gt;<a class="code" href="structdwc__otg__qh.html#o3">dev_speed</a>);
00584         }
00585 
00586         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[idx].<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o5">ioc</a> = 1;
00587 <span class="preprocessor">#endif</span>
00588 <span class="preprocessor"></span>}
00589 
00590 <span class="keyword">static</span> <span class="keywordtype">void</span> init_non_isoc_dma_desc(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00591 {
00592 
00593         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> *hc;
00594         <a class="code" href="dwc__otg__regs_8h.html#a157">dwc_otg_host_dma_desc_t</a> *dma_desc;
00595         <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> *qtd;
00596         <span class="keywordtype">int</span> num_packets, len, n_desc = 0;
00597 
00598         hc = qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>;
00599 
00600         <span class="comment">/* </span>
00601 <span class="comment">         * Start with hc-&gt;xfer_buff initialized in </span>
00602 <span class="comment">         * assign_and_init_hc(), then if SG transfer consists of multiple URBs,</span>
00603 <span class="comment">         * this pointer re-assigned to the buffer of the currently processed QTD.</span>
00604 <span class="comment">         * For non-SG request there is always one QTD active.</span>
00605 <span class="comment">         */</span>
00606 
00607         DWC_CIRCLEQ_FOREACH(qtd, &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry) {
00608 
00609                 <span class="keywordflow">if</span> (n_desc) {
00610                         <span class="comment">/* SG request - more than 1 QTDs */</span>
00611                         hc-&gt;<a class="code" href="structdwc__hc.html#z34_0">xfer_buff</a> = (uint8_t *)qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;dma + qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;actual_length;
00612                         hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a> = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;length - qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;actual_length;
00613                 }
00614 
00615                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o11">n_desc</a> = 0;
00616 
00617                 <span class="keywordflow">do</span> {
00618                         dma_desc = &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[n_desc];
00619                         len = hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a>;
00620 
00621                         <span class="keywordflow">if</span> (len &gt; MAX_DMA_DESC_SIZE)
00622                                 len = MAX_DMA_DESC_SIZE - hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a> + 1;
00623 
00624                         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a>) {
00625                                 <span class="keywordflow">if</span> (len &gt; 0) {
00626                                         num_packets = (len + hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a> - 1) / hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a>;
00627                                 } <span class="keywordflow">else</span> {
00628                                         <span class="comment">/* Need 1 packet for transfer length of 0. */</span>
00629                                         num_packets = 1;
00630                                 }
00631                                 <span class="comment">/* Always program an integral # of max packets for IN transfers. */</span>
00632                                 len = num_packets * hc-&gt;<a class="code" href="structdwc__hc.html#o6">max_packet</a>;
00633                         }
00634 
00635                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o1">n_bytes</a> = len;
00636 
00637                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[n_desc] = len;
00638 
00639                         <span class="keywordflow">if</span> ((qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_CONTROL)
00640                             &amp;&amp; (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> == DWC_OTG_CONTROL_SETUP))
00641                                 dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o4">sup</a> = 1;     <span class="comment">/* Setup Packet */</span>
00642 
00643                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o10">a</a> = 1;       <span class="comment">/* Active descriptor */</span>
00644                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o8">sts</a> = 0;
00645 
00646                         dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o1">buf</a> =
00647                             ((<span class="keywordtype">unsigned</span> long)hc-&gt;<a class="code" href="structdwc__hc.html#z34_0">xfer_buff</a> &amp; 0xffffffff);
00648 
00649                         <span class="comment">/* </span>
00650 <span class="comment">                         * Last descriptor(or single) of IN transfer </span>
00651 <span class="comment">                         * with actual size less than MaxPacket.</span>
00652 <span class="comment">                         */</span>
00653                         <span class="keywordflow">if</span> (len &gt; hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a>) {
00654                                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a> = 0;
00655                         } <span class="keywordflow">else</span> {
00656                                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_0">xfer_buff</a> += len;
00657                                 hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a> -= len;
00658                         }
00659 
00660                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o11">n_desc</a>++;
00661                         n_desc++;
00662                 }
00663                 <span class="keywordflow">while</span> ((hc-&gt;<a class="code" href="structdwc__hc.html#z34_2">xfer_len</a> &gt; 0) &amp;&amp; (n_desc != MAX_DMA_DESC_NUM_GENERIC));
00664                 
00665 
00666                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o10">in_process</a> = 1;
00667 
00668                 <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_CONTROL)
00669                         <span class="keywordflow">break</span>;
00670 
00671                 <span class="keywordflow">if</span> (n_desc == MAX_DMA_DESC_NUM_GENERIC)
00672                         <span class="keywordflow">break</span>;
00673         }
00674 
00675         <span class="keywordflow">if</span> (n_desc) {
00676                 <span class="comment">/* Request Transfer Complete interrupt for the last descriptor */</span>
00677                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[n_desc - 1].<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o5">ioc</a> = 1;
00678                 <span class="comment">/* End of List indicator */</span>
00679                 qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[n_desc - 1].<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o6">eol</a> = 1;
00680 
00681                 hc-&gt;<a class="code" href="structdwc__hc.html#z36_0">ntd</a> = n_desc;
00682         }
00683 }
00684 
<a name="l00702"></a><a class="code" href="dwc__otg__hcd__ddma_8c.html#a25">00702</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__ddma_8c.html#a25">dwc_otg_hcd_start_xfer_ddma</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd, <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> * qh)
00703 {
00704         <span class="comment">/* Channel is already assigned */</span>
00705         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> *hc = qh-&gt;<a class="code" href="structdwc__otg__qh.html#o7">channel</a>;
00706         uint8_t skip_frames = 0;
00707 
00708         <span class="keywordflow">switch</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a>) {
00709         <span class="keywordflow">case</span> DWC_OTG_EP_TYPE_CONTROL:
00710         <span class="keywordflow">case</span> DWC_OTG_EP_TYPE_BULK:
00711                 init_non_isoc_dma_desc(hcd, qh);
00712 
00713                 <a class="code" href="dwc__otg__cil_8h.html#a100">dwc_otg_hc_start_transfer_ddma</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc);
00714                 <span class="keywordflow">break</span>;
00715         <span class="keywordflow">case</span> DWC_OTG_EP_TYPE_INTR:
00716                 init_non_isoc_dma_desc(hcd, qh);
00717 
00718                 update_frame_list(hcd, qh, 1);
00719 
00720                 <a class="code" href="dwc__otg__cil_8h.html#a100">dwc_otg_hc_start_transfer_ddma</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc);
00721                 <span class="keywordflow">break</span>;
00722         <span class="keywordflow">case</span> DWC_OTG_EP_TYPE_ISOC:
00723 
00724                 <span class="keywordflow">if</span> (!qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a>)
00725                         skip_frames = recalc_initial_desc_idx(hcd, qh);
00726 
00727                 init_isoc_dma_desc(hcd, qh, skip_frames);
00728 
00729                 <span class="keywordflow">if</span> (!hc-&gt;<a class="code" href="structdwc__hc.html#z34_5">xfer_started</a>) {
00730 
00731                         update_frame_list(hcd, qh, 1);
00732 
00733                         <span class="comment">/* </span>
00734 <span class="comment">                         * Always set to max, instead of actual size.</span>
00735 <span class="comment">                         * Otherwise ntd will be changed with </span>
00736 <span class="comment">                         * channel being enabled. Not recommended.</span>
00737 <span class="comment">                         *</span>
00738 <span class="comment">                         */</span>
00739                         hc-&gt;<a class="code" href="structdwc__hc.html#z36_0">ntd</a> = max_desc_num(qh);
00740                         <span class="comment">/* Enable channel only once for ISOC */</span>
00741                         <a class="code" href="dwc__otg__cil_8h.html#a100">dwc_otg_hc_start_transfer_ddma</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc);
00742                 }
00743 
00744                 <span class="keywordflow">break</span>;
00745         <span class="keywordflow">default</span>:
00746 
00747                 <span class="keywordflow">break</span>;
00748         }
00749 }
00750 
00751 <span class="keyword">static</span> <span class="keywordtype">void</span> complete_isoc_xfer_ddma(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00752                                     <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00753                                     <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00754                                     dwc_otg_halt_status_e halt_status)
00755 {
00756         <span class="keyword">struct </span>dwc_otg_hcd_iso_packet_desc *frame_desc;
00757         <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> *qtd, *qtd_tmp;
00758         <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> *qh;
00759         <a class="code" href="dwc__otg__regs_8h.html#a157">dwc_otg_host_dma_desc_t</a> *dma_desc;
00760         uint16_t idx, remain;
00761         uint8_t urb_compl;
00762 
00763         qh = hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>;
00764         idx = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_4">td_first</a>;
00765 
00766         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a> == DWC_OTG_HC_XFER_URB_DEQUEUE) {
00767                 DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &amp;hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry)
00768                     qtd-&gt;in_process = 0;
00769                 return;
00770         } else if ((halt_status == DWC_OTG_HC_XFER_AHB_ERR) ||
00771                    (halt_status == DWC_OTG_HC_XFER_BABBLE_ERR)) {
00772                 <span class="comment">/* </span>
00773 <span class="comment">                 * Channel is halted in these error cases.</span>
00774 <span class="comment">                 * Considered as serious issues.</span>
00775 <span class="comment">                 * Complete all URBs marking all frames as failed, </span>
00776 <span class="comment">                 * irrespective whether some of the descriptors(frames) succeeded or no.</span>
00777 <span class="comment">                 * Pass error code to completion routine as well, to</span>
00778 <span class="comment">                 * update urb-&gt;status, some of class drivers might use it to stop</span>
00779 <span class="comment">                 * queing transfer requests.</span>
00780 <span class="comment">                 */</span>
00781                 <span class="keywordtype">int</span> err = (halt_status == DWC_OTG_HC_XFER_AHB_ERR)
00782                     ? (-DWC_E_IO)
00783                     : (-DWC_E_OVERFLOW);
00784                                                 
00785                 DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &amp;hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry) {
00786                         <span class="keywordflow">for</span> (idx = 0; idx &lt; qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;packet_count; idx++) {
00787                                 frame_desc = &amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;iso_descs[idx];
00788                                 frame_desc-&gt;status = err;
00789                         }
00790                         hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, err);
00791                         <a class="code" href="dwc__otg__hcd_8h.html#a59">dwc_otg_hcd_qtd_remove_and_free</a>(hcd, qtd, qh);
00792                 }
00793                 <span class="keywordflow">return</span>;
00794         }
00795 
00796         DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &amp;hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry) {
00797 
00798                 <span class="keywordflow">if</span> (!qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o10">in_process</a>)
00799                         <span class="keywordflow">break</span>;
00800 
00801                 urb_compl = 0;
00802 
00803                 <span class="keywordflow">do</span> {
00804 
00805                         dma_desc = &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[idx];
00806                         
00807                         frame_desc = &amp;qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;iso_descs[qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a>];
00808                         remain = hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> ? dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o1">n_bytes</a> : 0;
00809 
00810                         <span class="keywordflow">if</span> (dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o8">sts</a> == DMA_DESC_STS_PKTERR) {
00811                                 <span class="comment">/* </span>
00812 <span class="comment">                                 * XactError or, unable to complete all the transactions </span>
00813 <span class="comment">                                 * in the scheduled micro-frame/frame, </span>
00814 <span class="comment">                                 * both indicated by DMA_DESC_STS_PKTERR.</span>
00815 <span class="comment">                                 */</span>
00816                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;<a class="code" href="structdwc__otg__qtd.html#o4">error_count</a>++;
00817                                 frame_desc-&gt;actual_length = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[idx] - remain;
00818                                 frame_desc-&gt;status = -DWC_E_PROTOCOL;
00819                         } <span class="keywordflow">else</span> {
00820                                 <span class="comment">/* Success */</span>
00821                                                                 
00822                                 frame_desc-&gt;actual_length = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[idx] - remain;
00823                                 frame_desc-&gt;status = 0;
00824                         }
00825 
00826                         <span class="keywordflow">if</span> (++qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o5">isoc_frame_index</a> == qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;packet_count) {
00827                                 <span class="comment">/*</span>
00828 <span class="comment">                                 * urb-&gt;status is not used for isoc transfers here.</span>
00829 <span class="comment">                                 * The individual frame_desc status are used instead.</span>
00830 <span class="comment">                                 */</span>
00831 
00832                                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>-&gt;priv, qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>, 0);
00833                                 <a class="code" href="dwc__otg__hcd_8h.html#a59">dwc_otg_hcd_qtd_remove_and_free</a>(hcd, qtd, qh);
00834 
00835                                 <span class="comment">/* </span>
00836 <span class="comment">                                 * This check is necessary because urb_dequeue can be called </span>
00837 <span class="comment">                                 * from urb complete callback(sound driver example).</span>
00838 <span class="comment">                                 * All pending URBs are dequeued there, so no need for</span>
00839 <span class="comment">                                 * further processing.</span>
00840 <span class="comment">                                 */</span>
00841                                 <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a> == DWC_OTG_HC_XFER_URB_DEQUEUE) {   
00842                                         <span class="keywordflow">return</span>;
00843                                 }
00844 
00845                                 urb_compl = 1;
00846 
00847                         }
00848 
00849                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_3">ntd</a>--;
00850 
00851                         <span class="comment">/* Stop if IOC requested descriptor reached */</span>
00852                         <span class="keywordflow">if</span> (dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o14">b_isoc</a>.<a class="code" href="unionhost__dma__desc__sts.html#o5">ioc</a>) {
00853                                 idx = desclist_idx_inc(idx, qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>, hc-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a>);   
00854                                 <span class="keywordflow">goto</span> stop_scan;
00855                         }
00856 
00857                         idx = desclist_idx_inc(idx, qh-&gt;<a class="code" href="structdwc__otg__qh.html#z38_1">interval</a>, hc-&gt;<a class="code" href="structdwc__hc.html#o4">speed</a>);
00858 
00859                         <span class="keywordflow">if</span> (urb_compl)
00860                                 <span class="keywordflow">break</span>;
00861                 }
00862                 <span class="keywordflow">while</span> (idx != qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_4">td_first</a>);
00863         }
00864 stop_scan:
00865         qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_4">td_first</a> = idx;
00866 }
00867 
00868 uint8_t update_non_isoc_urb_state_ddma(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00869                                        <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00870                                        <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> * qtd,
00871                                        dwc_otg_host_dma_desc_t * dma_desc,
00872                                        dwc_otg_halt_status_e halt_status,
00873                                        uint32_t n_bytes, uint8_t * xfer_done)
00874 {
00875 
00876         uint16_t remain = hc-&gt;<a class="code" href="structdwc__hc.html#o3">ep_is_in</a> ? dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o1">n_bytes</a> : 0;
00877         dwc_otg_hcd_urb_t *urb = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>;
00878 
00879         <span class="keywordflow">if</span> (halt_status == DWC_OTG_HC_XFER_AHB_ERR) {
00880                 urb-&gt;status = -DWC_E_IO;
00881                 <span class="keywordflow">return</span> 1;
00882         }
00883         <span class="keywordflow">if</span> (dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o8">sts</a> == DMA_DESC_STS_PKTERR) {
00884                 <span class="keywordflow">switch</span> (halt_status) {
00885                 <span class="keywordflow">case</span> DWC_OTG_HC_XFER_STALL:
00886                         urb-&gt;status = -DWC_E_PIPE;
00887                         <span class="keywordflow">break</span>;
00888                 <span class="keywordflow">case</span> DWC_OTG_HC_XFER_BABBLE_ERR:
00889                         urb-&gt;status = -DWC_E_OVERFLOW;
00890                         <span class="keywordflow">break</span>;
00891                 <span class="keywordflow">case</span> DWC_OTG_HC_XFER_XACT_ERR:
00892                         urb-&gt;status = -DWC_E_PROTOCOL;
00893                         <span class="keywordflow">break</span>;
00894                 <span class="keywordflow">default</span>:        
00895                         DWC_ERROR(<span class="stringliteral">"%s: Unhandled descriptor error status (%d)\n"</span>, __func__,
00896                                   halt_status);
00897                         <span class="keywordflow">break</span>;
00898                 }
00899                 <span class="keywordflow">return</span> 1;
00900         }
00901 
00902         <span class="keywordflow">if</span> (dma_desc-&gt;<a class="code" href="structdwc__otg__host__dma__desc.html#o0">status</a>.<a class="code" href="unionhost__dma__desc__sts.html#o11">b</a>.<a class="code" href="unionhost__dma__desc__sts.html#o10">a</a> == 1) {
00903                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV,
00904                             <span class="stringliteral">"Active descriptor encountered on channel %d\n"</span>,
00905                             hc-&gt;<a class="code" href="structdwc__hc.html#o0">hc_num</a>);
00906                 <span class="keywordflow">return</span> 0;
00907         }
00908 
00909         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_CONTROL) {
00910                 <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> == DWC_OTG_CONTROL_DATA) {
00911                         urb-&gt;actual_length += n_bytes - remain;
00912                         <span class="keywordflow">if</span> (remain || urb-&gt;actual_length == urb-&gt;length) {
00913                                 <span class="comment">/* </span>
00914 <span class="comment">                                 * For Control Data stage do not set urb-&gt;status=0 to prevent</span>
00915 <span class="comment">                                 * URB callback. Set it when Status phase done. See below.</span>
00916 <span class="comment">                                 */</span>
00917                                 *xfer_done = 1;
00918                         }
00919 
00920                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> == DWC_OTG_CONTROL_STATUS) {
00921                         urb-&gt;status = 0;
00922                         *xfer_done = 1;
00923                 }
00924                 <span class="comment">/* No handling for SETUP stage */</span>
00925         } <span class="keywordflow">else</span> {
00926                 <span class="comment">/* BULK and INTR */</span>
00927                 urb-&gt;actual_length += n_bytes - remain;
00928                 <span class="keywordflow">if</span> (remain || urb-&gt;actual_length == urb-&gt;length) {
00929                         urb-&gt;status = 0;
00930                         *xfer_done = 1;
00931                 }
00932         }
00933 
00934         <span class="keywordflow">return</span> 0;
00935 }
00936 
00937 <span class="keyword">static</span> <span class="keywordtype">void</span> complete_non_isoc_xfer_ddma(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
00938                                         <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
00939                                         <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
00940                                         dwc_otg_halt_status_e halt_status)
00941 {
00942         dwc_otg_hcd_urb_t *urb = NULL;
00943         <a class="code" href="structdwc__otg__qtd.html">dwc_otg_qtd_t</a> *qtd, *qtd_tmp;
00944         <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> *qh;
00945         <a class="code" href="dwc__otg__regs_8h.html#a157">dwc_otg_host_dma_desc_t</a> *dma_desc;
00946         uint32_t n_bytes, n_desc, i;
00947         uint8_t failed = 0, xfer_done;
00948 
00949         n_desc = 0;
00950 
00951         qh = hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>;
00952 
00953         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#z34_10">halt_status</a> == DWC_OTG_HC_XFER_URB_DEQUEUE) {
00954                 DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &amp;hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry) {
00955                         qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o10">in_process</a> = 0;
00956                 }
00957                 <span class="keywordflow">return</span>;
00958         }
00959 
00960         DWC_CIRCLEQ_FOREACH_SAFE(qtd, qtd_tmp, &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>, qtd_list_entry) {
00961 
00962                 urb = qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o8">urb</a>;
00963 
00964                 n_bytes = 0;
00965                 xfer_done = 0;
00966 
00967                 <span class="keywordflow">for</span> (i = 0; i &lt; qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o11">n_desc</a>; i++) {
00968                         dma_desc = &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_0">desc_list</a>[n_desc];
00969 
00970                         n_bytes = qh-&gt;<a class="code" href="structdwc__otg__qh.html#z40_2">n_bytes</a>[n_desc];
00971 
00972                         failed =
00973                             update_non_isoc_urb_state_ddma(hcd, hc, qtd,
00974                                                            dma_desc,
00975                                                            halt_status, n_bytes,
00976                                                            &amp;xfer_done);
00977 
00978                         <span class="keywordflow">if</span> (failed
00979                             || (xfer_done
00980                                 &amp;&amp; (urb-&gt;status != -DWC_E_IN_PROGRESS))) {
00981 
00982                                 hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o2">fops</a>-&gt;complete(hcd, urb-&gt;<a class="code" href="structdwc__otg__hcd.html#o23">priv</a>, urb,
00983                                                     urb-&gt;status);
00984                                 <a class="code" href="dwc__otg__hcd_8h.html#a59">dwc_otg_hcd_qtd_remove_and_free</a>(hcd, qtd, qh);
00985 
00986                                 <span class="keywordflow">if</span> (failed)
00987                                         <span class="keywordflow">goto</span> stop_scan;
00988                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> == UE_CONTROL) {
00989                                 <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> == DWC_OTG_CONTROL_SETUP) {
00990                                         <span class="keywordflow">if</span> (urb-&gt;length &gt; 0) {
00991                                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> = DWC_OTG_CONTROL_DATA;
00992                                         } <span class="keywordflow">else</span> {
00993                                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> = DWC_OTG_CONTROL_STATUS;
00994                                         }
00995                                         <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  Control setup transaction done\n"</span>);
00996                                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> == DWC_OTG_CONTROL_DATA) {
00997                                         <span class="keywordflow">if</span> (xfer_done) {
00998                                                 qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o1">control_phase</a> = DWC_OTG_CONTROL_STATUS;
00999                                                 <a class="code" href="dwc__otg__dbg_8h.html#a10">DWC_DEBUGPL</a>(DBG_HCDV, <span class="stringliteral">"  Control data transfer done\n"</span>);
01000                                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i + 1 == qtd-&gt;<a class="code" href="structdwc__otg__qtd.html#o11">n_desc</a>) {
01001                                                 <span class="comment">/* </span>
01002 <span class="comment">                                                 * Last descriptor for Control data stage which is</span>
01003 <span class="comment">                                                 * not completed yet.</span>
01004 <span class="comment">                                                 */</span>
01005                                                 dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01006                                         }
01007                                 }
01008                         }
01009 
01010                         n_desc++;
01011                 }
01012 
01013         }
01014 
01015 stop_scan:
01016 
01017         <span class="keywordflow">if</span> (qh-&gt;<a class="code" href="structdwc__otg__qh.html#o0">ep_type</a> != UE_CONTROL) {
01018                 <span class="comment">/* </span>
01019 <span class="comment">                 * Resetting the data toggle for bulk</span>
01020 <span class="comment">                 * and interrupt endpoints in case of stall. See handle_hc_stall_intr() </span>
01021 <span class="comment">                 */</span>
01022                 <span class="keywordflow">if</span> (halt_status == DWC_OTG_HC_XFER_STALL)
01023                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#o4">data_toggle</a> = DWC_OTG_HC_PID_DATA0;
01024                 <span class="keywordflow">else</span>
01025                         dwc_otg_hcd_save_data_toggle(hc, hc_regs, qtd);
01026         }
01027 
01028         <span class="keywordflow">if</span> (halt_status == DWC_OTG_HC_XFER_COMPLETE) {
01029                 <a class="code" href="unionhcint__data.html">hcint_data_t</a> hcint;
01030                 hcint.<a class="code" href="unionhcint__data.html#o0">d32</a> = DWC_READ_REG32(&amp;hc_regs-&gt;<a class="code" href="structdwc__otg__hc__regs.html#o2">hcint</a>);
01031                 <span class="keywordflow">if</span> (hcint.<a class="code" href="unionhcint__data.html#o16">b</a>.<a class="code" href="unionhcint__data.html#o7">nyet</a>) {
01032                         <span class="comment">/*</span>
01033 <span class="comment">                         * Got a NYET on the last transaction of the transfer. It</span>
01034 <span class="comment">                         * means that the endpoint should be in the PING state at the</span>
01035 <span class="comment">                         * beginning of the next transfer.</span>
01036 <span class="comment">                         */</span>
01037                         qh-&gt;<a class="code" href="structdwc__otg__qh.html#o5">ping_state</a> = 1;
01038                         clear_hc_int(hc_regs, nyet);
01039                 }
01040 
01041         }
01042 
01043 }
01044 
<a name="l01062"></a><a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">01062</a> <span class="keywordtype">void</span> <a class="code" href="dwc__otg__hcd__ddma_8c.html#a29">dwc_otg_hcd_complete_xfer_ddma</a>(<a class="code" href="structdwc__otg__hcd.html">dwc_otg_hcd_t</a> * hcd,
01063                                     <a class="code" href="structdwc__hc.html">dwc_hc_t</a> * hc,
01064                                     <a class="code" href="structdwc__otg__hc__regs.html">dwc_otg_hc_regs_t</a> * hc_regs,
01065                                     dwc_otg_halt_status_e halt_status)
01066 {
01067         uint8_t continue_isoc_xfer = 0;
01068         <a class="code" href="dwc__otg__hcd_8h.html#a8">dwc_otg_transaction_type_e</a> tr_type;
01069         <a class="code" href="structdwc__otg__qh.html">dwc_otg_qh_t</a> *qh = hc-&gt;<a class="code" href="structdwc__hc.html#z34_18">qh</a>;
01070 
01071         <span class="keywordflow">if</span> (hc-&gt;<a class="code" href="structdwc__hc.html#o5">ep_type</a> == DWC_OTG_EP_TYPE_ISOC) {
01072 
01073                 complete_isoc_xfer_ddma(hcd, hc, hc_regs, halt_status);
01074 
01075                 <span class="comment">/* Release the channel if halted or session completed */</span>
01076                 <span class="keywordflow">if</span> (halt_status != DWC_OTG_HC_XFER_COMPLETE ||
01077                     DWC_CIRCLEQ_EMPTY(&amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>)) {
01078 
01079                         <span class="comment">/* Halt the channel if session completed */</span>
01080                         <span class="keywordflow">if</span> (halt_status == DWC_OTG_HC_XFER_COMPLETE) {
01081                                 <a class="code" href="dwc__otg__cil_8h.html#a92">dwc_otg_hc_halt</a>(hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o1">core_if</a>, hc, halt_status);
01082                         }
01083 
01084                         release_channel_ddma(hcd, qh);
01085                         <a class="code" href="dwc__otg__hcd__queue_8c.html#a16">dwc_otg_hcd_qh_remove</a>(hcd, qh);
01086                 } <span class="keywordflow">else</span> {
01087                         <span class="comment">/* Keep in assigned schedule to continue transfer */</span>
01088                         DWC_LIST_MOVE_HEAD(&amp;hcd-&gt;<a class="code" href="structdwc__otg__hcd.html#o9">periodic_sched_assigned</a>,
01089                                            &amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o11">qh_list_entry</a>);
01090                         continue_isoc_xfer = 1;
01091 
01092                 }
01096         } <span class="keywordflow">else</span> {
01097                 <span class="comment">/* Scan descriptor list to complete the URB(s), then release the channel */</span>
01098                 complete_non_isoc_xfer_ddma(hcd, hc, hc_regs, halt_status);
01099 
01100                 release_channel_ddma(hcd, qh);
01101                 <a class="code" href="dwc__otg__hcd__queue_8c.html#a16">dwc_otg_hcd_qh_remove</a>(hcd, qh);
01102 
01103                 <span class="keywordflow">if</span> (!DWC_CIRCLEQ_EMPTY(&amp;qh-&gt;<a class="code" href="structdwc__otg__qh.html#o6">qtd_list</a>)) {
01104                         <span class="comment">/* Add back to inactive non-periodic schedule on normal completion */</span>
01105                         <a class="code" href="dwc__otg__hcd__queue_8c.html#a14">dwc_otg_hcd_qh_add</a>(hcd, qh);
01106                 }
01107 
01108         }
01109         tr_type = <a class="code" href="dwc__otg__hcd_8h.html#a31">dwc_otg_hcd_select_transactions</a>(hcd);
01110         <span class="keywordflow">if</span> (tr_type != DWC_OTG_TRANSACTION_NONE || continue_isoc_xfer) {
01111                 <span class="keywordflow">if</span> (continue_isoc_xfer) {
01112                         <span class="keywordflow">if</span> (tr_type == DWC_OTG_TRANSACTION_NONE) {
01113                                 tr_type = DWC_OTG_TRANSACTION_PERIODIC;
01114                         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tr_type == DWC_OTG_TRANSACTION_NON_PERIODIC) {
01115                                 tr_type = DWC_OTG_TRANSACTION_ALL;
01116                         }
01117                 }
01118                 <a class="code" href="dwc__otg__hcd_8h.html#a32">dwc_otg_hcd_queue_transactions</a>(hcd, tr_type);
01119         }
01120 }
01121 
01122 <span class="preprocessor">#endif </span><span class="comment">/* DWC_DEVICE_ONLY */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Oct 27 03:56:37 2011 for DesignWare USB 2.0 OTG Controller (DWC_otg) Device Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
